C*** Modifications:
C 6/5/97 Increased maxnum to 5000 (from 500) so it will run further before
C    interrupting.  MJK
C
C*** NOTE: THIS PACKAGE CONTAINS TWO ROUTINES WITH MACHINE DEPENDENT
C          PARAMETERS D1MACH AND I1MACH.  CONSTANTS ARE GIVEN FOR
C          MANY MACHINES - BE SURE TO SELECT THE PROPER VALUES 
C          BEFORE RUNNING THIS PACKAGE. OTHERWISE YOU WILL 
C          GET COMPILATION ERRORS AND/OR GARBAGE RESULTS.
C
C*** NOTE: THE DOCUMENTATION ABSTRACT FOR CALLING DDEBDF IS
C          FOUND AT THE BEGINNING OF SUBROUTINE DDEBDF, LOCATED
C          ON LINE 1003 OF THIS PACKAGE.
C
      DOUBLE PRECISION FUNCTION D1MACH(I)
C***BEGIN PROLOGUE  D1MACH
C***DATE WRITTEN   750101   (YYMMDD)
C***REVISION DATE  820801   (YYMMDD)
C***CATEGORY NO.  R1
C***KEYWORDS  MACHINE CONSTANTS
C***AUTHOR  FOX, P. A., (BELL LABS)
C           HALL, A. D., (BELL LABS)
C           SCHRYER, N. L., (BELL LABS)
C***PURPOSE  RETURNS DOUBLE PRECISION MACHINE DEPENDENT CONSTANTS
C***DESCRIPTION
C     D1MACH CAN BE USED TO OBTAIN MACHINE-DEPENDENT PARAMETERS
C     FOR THE LOCAL MACHINE ENVIRONMENT.  IT IS A FUNCTION
C     SUBPROGRAM WITH ONE (INPUT) ARGUMENT, AND CAN BE CALLED
C     AS FOLLOWS, FOR EXAMPLE
C
C          D = D1MACH(I)
C
C     WHERE I=1,...,5.  THE (OUTPUT) VALUE OF D ABOVE IS
C     DETERMINED BY THE (INPUT) VALUE OF I.  THE RESULTS FOR
C     VARIOUS VALUES OF I ARE DISCUSSED BELOW.
C
C  DOUBLE-PRECISION MACHINE CONSTANTS
C  D1MACH( 1) = B**(EMIN-1), THE SMALLEST POSITIVE MAGNITUDE.
C  D1MACH( 2) = B**EMAX*(1 - B**(-T)), THE LARGEST MAGNITUDE.
C  D1MACH( 3) = B**(-T), THE SMALLEST RELATIVE SPACING.
C  D1MACH( 4) = B**(1-T), THE LARGEST RELATIVE SPACING.
C  D1MACH( 5) = LOG10(B)
C***REFERENCES  FOX P.A., HALL A.D., SCHRYER N.L.,*FRAMEWORK FOR A
C                 PORTABLE LIBRARY*, ACM TRANSACTIONS ON MATHEMATICAL
C                 SOFTWARE, VOL. 4, NO. 2, JUNE 1978, PP. 177-188.
C***ROUTINES CALLED  XERROR
C***END PROLOGUE  D1MACH
C
      INTEGER SMALL(4)
      INTEGER LARGE(4)
      INTEGER RIGHT(4)
      INTEGER DIVER(4)
      INTEGER LOG10(4)
C
      DOUBLE PRECISION DMACH(5)
C
      EQUIVALENCE (DMACH(1),SMALL(1))
      EQUIVALENCE (DMACH(2),LARGE(1))
      EQUIVALENCE (DMACH(3),RIGHT(1))
      EQUIVALENCE (DMACH(4),DIVER(1))
      EQUIVALENCE (DMACH(5),LOG10(1))
C
C     MACHINE CONSTANTS FOR THE BURROUGHS 1700 SYSTEM.
C
C     DATA SMALL(1) / ZC00800000 /
C     DATA SMALL(2) / Z000000000 /
C
C     DATA LARGE(1) / ZDFFFFFFFF /
C     DATA LARGE(2) / ZFFFFFFFFF /
C
C     DATA RIGHT(1) / ZCC5800000 /
C     DATA RIGHT(2) / Z000000000 /
C
C     DATA DIVER(1) / ZCC6800000 /
C     DATA DIVER(2) / Z000000000 /
C
C     DATA LOG10(1) / ZD00E730E7 /
C     DATA LOG10(2) / ZC77800DC0 /
C
C     MACHINE CONSTANTS FOR THE BURROUGHS 5700 SYSTEM.
C
C     DATA SMALL(1) / O1771000000000000 /
C     DATA SMALL(2) / O0000000000000000 /
C
C     DATA LARGE(1) / O0777777777777777 /
C     DATA LARGE(2) / O0007777777777777 /
C
C     DATA RIGHT(1) / O1461000000000000 /
C     DATA RIGHT(2) / O0000000000000000 /
C
C     DATA DIVER(1) / O1451000000000000 /
C     DATA DIVER(2) / O0000000000000000 /
C
C     DATA LOG10(1) / O1157163034761674 /
C     DATA LOG10(2) / O0006677466732724 /
C
C     MACHINE CONSTANTS FOR THE BURROUGHS 6700/7700 SYSTEMS.
C
C     DATA SMALL(1) / O1771000000000000 /
C     DATA SMALL(2) / O7770000000000000 /
C
C     DATA LARGE(1) / O0777777777777777 /
C     DATA LARGE(2) / O7777777777777777 /
C
C     DATA RIGHT(1) / O1461000000000000 /
C     DATA RIGHT(2) / O0000000000000000 /
C
C     DATA DIVER(1) / O1451000000000000 /
C     DATA DIVER(2) / O0000000000000000 /
C
C     DATA LOG10(1) / O1157163034761674 /
C     DATA LOG10(2) / O0006677466732724 /
C
C     MACHINE CONSTANTS FOR THE CDC 6000/7000 SERIES.
C
C     DATA SMALL(1) / 00604000000000000000B /
C     DATA SMALL(2) / 00000000000000000000B /
C
C     DATA LARGE(1) / 37767777777777777777B /
C     DATA LARGE(2) / 37167777777777777777B /
C
C     DATA RIGHT(1) / 15604000000000000000B /
C     DATA RIGHT(2) / 15000000000000000000B /
C
C     DATA DIVER(1) / 15614000000000000000B /
C     DATA DIVER(2) / 15010000000000000000B /
C
C     DATA LOG10(1) / 17164642023241175717B /
C     DATA LOG10(2) / 16367571421742254654B /
C
C     MACHINE CONSTANTS FOR THE CRAY 1
C
C     DATA SMALL(1) / 200004000000000000000B /
C     DATA SMALL(2) / 00000000000000000000B /
C
C     DATA LARGE(1) / 577777777777777777777B /
C     DATA LARGE(2) / 000007777777777777777B /
C
C     DATA RIGHT(1) / 377214000000000000000B /
C     DATA RIGHT(2) / 000000000000000000000B /
C
C     DATA DIVER(1) / 377224000000000000000B /
C     DATA DIVER(2) / 000000000000000000000B /
C
C     DATA LOG10(1) / 377774642023241175717B /
C     DATA LOG10(2) / 000007571421742254654B /
C
C     MACHINE CONSTANTS FOR THE DATA GENERAL ECLIPSE S/200
C
C     NOTE - IT MAY BE APPROPRIATE TO INCLUDE THE FOLLOWING CARD -
C     STATIC DMACH(5)
C
C     DATA SMALL/20K,3*0/,LARGE/77777K,3*177777K/
C     DATA RIGHT/31420K,3*0/,DIVER/32020K,3*0/
C     DATA LOG10/40423K,42023K,50237K,74776K/
C
C     MACHINE CONSTANTS FOR THE HARRIS 220
C
C     DATA SMALL(1),SMALL(2) / [20000000, [00000201 /
C     DATA LARGE(1),LARGE(2) / [37777777, [37777577 /
C     DATA RIGHT(1),RIGHT(2) / [20000000, [00000333 /
C     DATA DIVER(1),DIVER(2) / [20000000, [00000334 /
C     DATA LOG10(1),LOG10(2) / [23210115, [10237777 /
C
C     MACHINE CONSTANTS FOR THE HONEYWELL 600/6000 SERIES.
C
C     DATA SMALL(1),SMALL(2) / O402400000000, O000000000000 /
C     DATA LARGE(1),LARGE(2) / O376777777777, O777777777777 /
C     DATA RIGHT(1),RIGHT(2) / O604400000000, O000000000000 /
C     DATA DIVER(1),DIVER(2) / O606400000000, O000000000000 /
C     DATA LOG10(1),LOG10(2) / O776464202324, O117571775714 /
C
C      MACHINE CONSTANTS FOR THE HP 2100
C      THREE WORD DOUBLE PRECISION OPTION WITH FTN4
C
C      DATA SMALL(1), SMALL(2), SMALL(3) / 40000B,       0,       1 /
C      DATA LARGE(1), LARGE(2), LARGE(3) / 77777B, 177777B, 177776B /
C      DATA RIGHT(1), RIGHT(2), RIGHT(3) / 40000B,       0,    265B /
C      DATA DIVER(1), DIVER(2), DIVER(3) / 40000B,       0,    276B /
C      DATA LOG10(1), LOG10(2), LOG10(3) / 46420B,  46502B,  77777B /
C
C
C      MACHINE CONSTANTS FOR THE HP 2100
C      FOUR WORD DOUBLE PRECISION OPTION WITH FTN4
C
C      DATA SMALL(1), SMALL(2) /  40000B,       0 /
C      DATA SMALL(3), SMALL(4) /       0,       1 /
C      DATA LARGE(1), LARGE(2) /  77777B, 177777B /
C      DATA LARGE(3), LARGE(4) / 177777B, 177776B /
C      DATA RIGHT(1), RIGHT(2) /  40000B,       0 /
C      DATA RIGHT(3), RIGHT(4) /       0,    225B /
C      DATA DIVER(1), DIVER(2) /  40000B,       0 /
C      DATA DIVER(3), DIVER(4) /       0,    227B /
C      DATA LOG10(1), LOG10(2) /  46420B,  46502B /
C      DATA LOG10(3), LOG10(4) /  76747B, 176377B /
C
C  MACHINE CONSTANTS FOR IBM PC, XT, WITH R-M COMPILER
C
C      DATA SMALL(1), SMALL(2) /          0,      524288/
C      DATA LARGE(1), LARGE(2) /         -2,  2145386495/
C      DATA RIGHT(1), RIGHT(2) /          0,  1018167296/
C      DATA DIVER(1), DIVER(2) /          0,  1019215872/
C      DATA LOG10(1), LOG10(2) / 1352628735,  1070810131/
C
C  MACHINE CONSTANTS FOR SUN (KROK 13 SEPT 93, FROM DMATH)
C
C      DATA SMALL(1), SMALL(2) /Z'00100000', Z'00000000'/
C      DATA LARGE(1), LARGE(2) /Z'7FEFFFFF', Z'FFFFFFFF'/
C      DATA RIGHT(1), RIGHT(2) /Z'3CA00000', Z'00000000'/
C      DATA DIVER(1), DIVER(2) /Z'3CB00000', Z'00000000'/
C      DATA LOG10(1), LOG10(2) /Z'3FD34413', Z'509F79FF'/
C
C  MACHINE CONSTANTS FOR GCC 2.95.2 compiler on x86 JES 02-06-00
C
       DATA SMALL(1), SMALL(2) /Z'00000000', Z'00100000'/
       DATA LARGE(1), LARGE(2) /Z'FFFFFFFF', Z'7FEFFFFF'/
       DATA RIGHT(1), RIGHT(2) /Z'00000000', Z'3CA00000'/
       DATA DIVER(1), DIVER(2) /Z'00000000', Z'3CB00000'/
       DATA LOG10(1), LOG10(2) /Z'509F79FF', Z'3FD34413'/
C
C     MACHINE CONSTANTS FOR THE IBM 360/370 SERIES,
C     THE XEROX SIGMA 5/7/9, THE SEL SYSTEMS 85/86, AND
C     THE PERKIN ELMER (INTERDATA) 7/32.
C
C     DATA SMALL(1),SMALL(2) / Z00100000, Z00000000 /
C     DATA LARGE(1),LARGE(2) / Z7FFFFFFF, ZFFFFFFFF /
C     DATA RIGHT(1),RIGHT(2) / Z33100000, Z00000000 /
C     DATA DIVER(1),DIVER(2) / Z34100000, Z00000000 /
C     DATA LOG10(1),LOG10(2) / Z41134413, Z509F79FF /
C
C     MACHINE CONSTANTS FOR THE PDP-10 (KA PROCESSOR).
C
C     DATA SMALL(1),SMALL(2) / "033400000000, "000000000000 /
C     DATA LARGE(1),LARGE(2) / "377777777777, "344777777777 /
C     DATA RIGHT(1),RIGHT(2) / "113400000000, "000000000000 /
C     DATA DIVER(1),DIVER(2) / "114400000000, "000000000000 /
C     DATA LOG10(1),LOG10(2) / "177464202324, "144117571776 /
C
C     MACHINE CONSTANTS FOR THE PDP-10 (KI PROCESSOR).
C
C     DATA SMALL(1),SMALL(2) / "000400000000, "000000000000 /
C     DATA LARGE(1),LARGE(2) / "377777777777, "377777777777 /
C     DATA RIGHT(1),RIGHT(2) / "103400000000, "000000000000 /
C     DATA DIVER(1),DIVER(2) / "104400000000, "000000000000 /
C     DATA LOG10(1),LOG10(2) / "177464202324, "476747767461 /
C
C     MACHINE CONSTANTS FOR PDP-11 FORTRAN[S SUPPORTING
C     32-BIT INTEGERS (EXPRESSED IN INTEGER AND OCTAL).
C
C     DATA SMALL(1),SMALL(2) /    8388608,           0 /
C     DATA LARGE(1),LARGE(2) / 2147483647,          -1 /
C     DATA RIGHT(1),RIGHT(2) /  612368384,           0 /
C     DATA DIVER(1),DIVER(2) /  620756992,           0 /
C     DATA LOG10(1),LOG10(2) / 1067065498, -2063872008 /
C
C     DATA SMALL(1),SMALL(2) / O00040000000, O00000000000 /
C     DATA LARGE(1),LARGE(2) / O17777777777, O37777777777 /
C     DATA RIGHT(1),RIGHT(2) / O04440000000, O00000000000 /
C     DATA DIVER(1),DIVER(2) / O04500000000, O00000000000 /
C     DATA LOG10(1),LOG10(2) / O07746420232, O20476747770 /
C
C     MACHINE CONSTANTS FOR PDP-11 FORTRAN[S SUPPORTING
C     16-BIT INTEGERS (EXPRESSED IN INTEGER AND OCTAL).
C
C     DATA SMALL(1),SMALL(2) /    128,      0 /
C     DATA SMALL(3),SMALL(4) /      0,      0 /
C
C     DATA LARGE(1),LARGE(2) /  32767,     -1 /
C     DATA LARGE(3),LARGE(4) /     -1,     -1 /
C
C     DATA RIGHT(1),RIGHT(2) /   9344,      0 /
C     DATA RIGHT(3),RIGHT(4) /      0,      0 /
C
C     DATA DIVER(1),DIVER(2) /   9472,      0 /
C     DATA DIVER(3),DIVER(4) /      0,      0 /
C
C     DATA LOG10(1),LOG10(2) /  16282,   8346 /
C     DATA LOG10(3),LOG10(4) / -31493, -12296 /
C
C     DATA SMALL(1),SMALL(2) / O000200, O000000 /
C     DATA SMALL(3),SMALL(4) / O000000, O000000 /
C
C     DATA LARGE(1),LARGE(2) / O077777, O177777 /
C     DATA LARGE(3),LARGE(4) / O177777, O177777 /
C
C     DATA RIGHT(1),RIGHT(2) / O022200, O000000 /
C     DATA RIGHT(3),RIGHT(4) / O000000, O000000 /
C
C     DATA DIVER(1),DIVER(2) / O022400, O000000 /
C     DATA DIVER(3),DIVER(4) / O000000, O000000 /
C
C     DATA LOG10(1),LOG10(2) / O037632, O020232 /
C     DATA LOG10(3),LOG10(4) / O102373, O147770 /
C
C     MACHINE CONSTANTS FOR THE UNIVAC 1100 SERIES. FTN COMPILER
C
C     DATA SMALL(1),SMALL(2) / O000040000000, O000000000000 /
C     DATA LARGE(1),LARGE(2) / O377777777777, O777777777777 /
C     DATA RIGHT(1),RIGHT(2) / O170540000000, O000000000000 /
C     DATA DIVER(1),DIVER(2) / O170640000000, O000000000000 /
C     DATA LOG10(1),LOG10(2) / O177746420232, O411757177572 /
C
C     MACHINE CONSTANTS FOR THE UNIVAC 1100 SERIES. FOR COMPILER
C
C     DATA SMALL(1), SMALL(2) / O000040000000, O000000000000 /
C     DATA LARGE(1), LARGE(2) / O377777777777, O777777777777 /
C     DATA RIGHT(1), RIGHT(2) / O170540000000, O000000000000 /
C     DATA DIVER(1), DIVER(2) / O170640000000, O000000000000 /
C     DATA LOG10(1), LOG10(2) / O177746420232, O411757177572/
C
C
C     MACHINE CONSTANTS FOR VAX 11/780
C     (EXPRESSED IN INTEGER AND HEXADECIMAL)
C    ***THE HEX FORMAT BELOW MAY NOT BE SUITABLE FOR UNIX SYSYEMS***
C    *** THE INTEGER FORMAT SHOULD BE OK FOR UNIX SYSTEMS***
C
C     DATA SMALL(1), SMALL(2) /        128,           0 /
C     DATA LARGE(1), LARGE(2) /     -32769,          -1 /
C     DATA RIGHT(1), RIGHT(2) /       9344,           0 /
C     DATA DIVER(1), DIVER(2) /       9472,           0 /
C     DATA LOG10(1), LOG10(2) /  546979738,  -805665541 /
C
C     DATA SMALL(1), SMALL(2) / Z00000080, Z00000000 /
C     DATA LARGE(1), LARGE(2) / ZFFFF7FFF, ZFFFFFFFF /
C     DATA RIGHT(1), RIGHT(2) / Z00002480, Z00000000 /
C     DATA DIVER(1), DIVER(2) / Z00002500, Z00000000 /
C     DATA LOG10(1), LOG10(2) / Z209A3F9A, ZCFFA84FB /
C
C***FIRST EXECUTABLE STATEMENT  D1MACH
C
      IF (I .LT. 1  .OR.  I .GT. 5) THEN
        WRITE (6,1000) I
 1000   FORMAT('D1MACH -- I = ',I3,' OUT OF BOUNDS')
        D1MACH = 0.0D0
      ELSE
        D1MACH = DMACH(I)
      ENDIF
      RETURN
      END
C
      INTEGER FUNCTION I1MACH(I)
C***BEGIN PROLOGUE  I1MACH
C***DATE WRITTEN   750101   (YYMMDD)
C***REVISION DATE  820801   (YYMMDD)
C***CATEGORY NO.  R1
C***KEYWORDS  MACHINE CONSTANTS
C***AUTHOR  FOX, P. A., (BELL LABS)
C           HALL, A. D., (BELL LABS)
C           SCHRYER, N. L., (BELL LABS)
C***PURPOSE  RETURNS INTEGER MACHINE DEPENDENT CONSTANTS
C***DESCRIPTION
C * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
C   THESE MACHINE CONSTANT ROUTINES MUST BE ACTIVATED FOR
C   A PARTICULAR ENVIRONMENT.
C * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
C
C     I1MACH CAN BE USED TO OBTAIN MACHINE-DEPENDENT PARAMETERS
C     FOR THE LOCAL MACHINE ENVIRONMENT.  IT IS A FUNCTION
C     SUBROUTINE WITH ONE (INPUT) ARGUMENT, AND CAN BE CALLED
C     AS FOLLOWS, FOR EXAMPLE
C
C          K = I1MACH(I)
C
C     WHERE I=1,...,16.  THE (OUTPUT) VALUE OF K ABOVE IS
C     DETERMINED BY THE (INPUT) VALUE OF I.  THE RESULTS FOR
C     VARIOUS VALUES OF I ARE DISCUSSED BELOW.
C
C  I/O UNIT NUMBERS.
C    I1MACH( 1) = THE STANDARD INPUT UNIT.
C    I1MACH( 2) = THE STANDARD OUTPUT UNIT.
C    I1MACH( 3) = THE STANDARD PUNCH UNIT.
C    I1MACH( 4) = THE STANDARD ERROR MESSAGE UNIT.
C
C  WORDS.
C    I1MACH( 5) = THE NUMBER OF BITS PER INTEGER STORAGE UNIT.
C    I1MACH( 6) = THE NUMBER OF CHARACTERS PER INTEGER STORAGE UNIT.
C
C  INTEGERS.
C    ASSUME INTEGERS ARE REPRESENTED IN THE S-DIGIT, BASE-A FORM
C
C               SIGN ( X(S-1)*A**(S-1) + ... + X(1)*A + X(0) )
C
C               WHERE 0 .LE. X(I) .LT. A FOR I=0,...,S-1.
C    I1MACH( 7) = A, THE BASE.
C    I1MACH( 8) = S, THE NUMBER OF BASE-A DIGITS.
C    I1MACH( 9) = A**S - 1, THE LARGEST MAGNITUDE.
C
C  FLOATING-POINT NUMBERS.
C    ASSUME FLOATING-POINT NUMBERS ARE REPRESENTED IN THE T-DIGIT,
C    BASE-B FORM
C               SIGN (B**E)*( (X(1)/B) + ... + (X(T)/B**T) )
C
C               WHERE 0 .LE. X(I) .LT. B FOR I=1,...,T,
C               0 .LT. X(1), AND EMIN .LE. E .LE. EMAX.
C    I1MACH(10) = B, THE BASE.
C
C  SINGLE-PRECISION
C    I1MACH(11) = T, THE NUMBER OF BASE-B DIGITS.
C    I1MACH(12) = EMIN, THE SMALLEST EXPONENT E.
C    I1MACH(13) = EMAX, THE LARGEST EXPONENT E.
C
C  DOUBLE-PRECISION
C    I1MACH(14) = T, THE NUMBER OF BASE-B DIGITS.
C    I1MACH(15) = EMIN, THE SMALLEST EXPONENT E.
C    I1MACH(16) = EMAX, THE LARGEST EXPONENT E.
C
C  TO ALTER THIS FUNCTION FOR A PARTICULAR ENVIRONMENT,
C  THE DESIRED SET OF DATA STATEMENTS SHOULD BE ACTIVATED BY
C  REMOVING THE C FROM COLUMN 1.  ALSO, THE VALUES OF
C  I1MACH(1) - I1MACH(4) SHOULD BE CHECKED FOR CONSISTENCY
C  WITH THE LOCAL OPERATING SYSTEM.
C***REFERENCES  FOX P.A., HALL A.D., SCHRYER N.L.,*FRAMEWORK FOR A
C                 PORTABLE LIBRARY*, ACM TRANSACTIONS ON MATHEMATICAL
C                 SOFTWARE, VOL. 4, NO. 2, JUNE 1978, PP. 177-188.
C***ROUTINES CALLED  (NONE)
C***END PROLOGUE  I1MACH
C
      INTEGER IMACH(16),OUTPUT
      EQUIVALENCE (IMACH(4),OUTPUT)
C
C     MACHINE CONSTANTS FOR THE BURROUGHS 1700 SYSTEM.
C
C     DATA IMACH( 1) /    7 /
C     DATA IMACH( 2) /    2 /
C     DATA IMACH( 3) /    2 /
C     DATA IMACH( 4) /    2 /
C     DATA IMACH( 5) /   36 /
C     DATA IMACH( 6) /    4 /
C     DATA IMACH( 7) /    2 /
C     DATA IMACH( 8) /   33 /
C     DATA IMACH( 9) / Z1FFFFFFFF /
C     DATA IMACH(10) /    2 /
C     DATA IMACH(11) /   24 /
C     DATA IMACH(12) / -256 /
C     DATA IMACH(13) /  255 /
C     DATA IMACH(14) /   60 /
C     DATA IMACH(15) / -256 /
C     DATA IMACH(16) /  255 /
C
C     MACHINE CONSTANTS FOR THE BURROUGHS 5700 SYSTEM.
C
C     DATA IMACH( 1) /   5 /
C     DATA IMACH( 2) /   6 /
C     DATA IMACH( 3) /   7 /
C     DATA IMACH( 4) /   6 /
C     DATA IMACH( 5) /  48 /
C     DATA IMACH( 6) /   6 /
C     DATA IMACH( 7) /   2 /
C     DATA IMACH( 8) /  39 /
C     DATA IMACH( 9) / O0007777777777777 /
C     DATA IMACH(10) /   8 /
C     DATA IMACH(11) /  13 /
C     DATA IMACH(12) / -50 /
C     DATA IMACH(13) /  76 /
C     DATA IMACH(14) /  26 /
C     DATA IMACH(15) / -50 /
C     DATA IMACH(16) /  76 /
C
C     MACHINE CONSTANTS FOR THE BURROUGHS 6700/7700 SYSTEMS.
C
C     DATA IMACH( 1) /   5 /
C     DATA IMACH( 2) /   6 /
C     DATA IMACH( 3) /   7 /
C     DATA IMACH( 4) /   6 /
C     DATA IMACH( 5) /  48 /
C     DATA IMACH( 6) /   6 /
C     DATA IMACH( 7) /   2 /
C     DATA IMACH( 8) /  39 /
C     DATA IMACH( 9) / O0007777777777777 /
C     DATA IMACH(10) /   8 /
C     DATA IMACH(11) /  13 /
C     DATA IMACH(12) / -50 /
C     DATA IMACH(13) /  76 /
C     DATA IMACH(14) /  26 /
C     DATA IMACH(15) / -32754 /
C     DATA IMACH(16) /  32780 /
C
C     MACHINE CONSTANTS FOR THE CDC 6000/7000 SERIES.
C
C     DATA IMACH( 1) /    5 /
C     DATA IMACH( 2) /    6 /
C     DATA IMACH( 3) /    7 /
C     DATA IMACH( 4) /6LOUTPUT/
C     DATA IMACH( 5) /   60 /
C     DATA IMACH( 6) /   10 /
C     DATA IMACH( 7) /    2 /
C     DATA IMACH( 8) /   48 /
C     DATA IMACH( 9) / 00007777777777777777B /
C     DATA IMACH(10) /    2 /
C     DATA IMACH(11) /   48 /
C     DATA IMACH(12) / -974 /
C     DATA IMACH(13) / 1070 /
C     DATA IMACH(14) /   96 /
C     DATA IMACH(15) / -927 /
C     DATA IMACH(16) / 1070 /
C
C     MACHINE CONSTANTS FOR THE CRAY 1
C
C     DATA IMACH( 1) /   100 /
C     DATA IMACH( 2) /   101 /
C     DATA IMACH( 3) /   102 /
C     DATA IMACH( 4) /   101 /
C     DATA IMACH( 5) /    64 /
C     DATA IMACH( 6) /     8 /
C     DATA IMACH( 7) /     2 /
C     DATA IMACH( 8) /    63 /
C     DATA IMACH( 9) /  777777777777777777777B /
C     DATA IMACH(10) /     2 /
C     DATA IMACH(11) /    48 /
C     DATA IMACH(12) / -8192 /
C     DATA IMACH(13) /  8191 /
C     DATA IMACH(14) /    96 /
C     DATA IMACH(15) / -8192 /
C     DATA IMACH(16) /  8191 /
C
C     MACHINE CONSTANTS FOR THE DATA GENERAL ECLIPSE S/200
C
C     DATA IMACH( 1) /   11 /
C     DATA IMACH( 2) /   12 /
C     DATA IMACH( 3) /    8 /
C     DATA IMACH( 4) /   10 /
C     DATA IMACH( 5) /   16 /
C     DATA IMACH( 6) /    2 /
C     DATA IMACH( 7) /    2 /
C     DATA IMACH( 8) /   15 /
C     DATA IMACH( 9) /32767 /
C     DATA IMACH(10) /   16 /
C     DATA IMACH(11) /    6 /
C     DATA IMACH(12) /  -64 /
C     DATA IMACH(13) /   63 /
C     DATA IMACH(14) /   14 /
C     DATA IMACH(15) /  -64 /
C     DATA IMACH(16) /   63 /
C
C     MACHINE CONSTANTS FOR THE HARRIS 220
C
C     DATA IMACH( 1) /       5 /
C     DATA IMACH( 2) /       6 /
C     DATA IMACH( 3) /       0 /
C     DATA IMACH( 4) /       6 /
C     DATA IMACH( 5) /      24 /
C     DATA IMACH( 6) /       3 /
C     DATA IMACH( 7) /       2 /
C     DATA IMACH( 8) /      23 /
C     DATA IMACH( 9) / 8388607 /
C     DATA IMACH(10) /       2 /
C     DATA IMACH(11) /      23 /
C     DATA IMACH(12) /    -127 /
C     DATA IMACH(13) /     127 /
C     DATA IMACH(14) /      38 /
C     DATA IMACH(15) /    -127 /
C     DATA IMACH(16) /     127 /
C
C     MACHINE CONSTANTS FOR THE HONEYWELL 600/6000 SERIES.
C
C     DATA IMACH( 1) /    5 /
C     DATA IMACH( 2) /    6 /
C     DATA IMACH( 3) /   43 /
C     DATA IMACH( 4) /    6 /
C     DATA IMACH( 5) /   36 /
C     DATA IMACH( 6) /    6 /
C     DATA IMACH( 7) /    2 /
C     DATA IMACH( 8) /   35 /
C     DATA IMACH( 9) / O377777777777 /
C     DATA IMACH(10) /    2 /
C     DATA IMACH(11) /   27 /
C     DATA IMACH(12) / -127 /
C     DATA IMACH(13) /  127 /
C     DATA IMACH(14) /   63 /
C     DATA IMACH(15) / -127 /
C     DATA IMACH(16) /  127 /
C
C     MACHINE CONSTANTS FOR THE HP 2100
C     3 WORD DOUBLE PRECISION OPTION WITH FTN4
C
C     DATA IMACH(1) /      5/
C     DATA IMACH(2) /      6 /
C     DATA IMACH(3) /      4 /
C     DATA IMACH(4) /      1 /
C     DATA IMACH(5) /     16 /
C     DATA IMACH(6) /      2 /
C     DATA IMACH(7) /      2 /
C     DATA IMACH(8) /     15 /
C     DATA IMACH(9) /  32767 /
C     DATA IMACH(10)/      2 /
C     DATA IMACH(11)/     23 /
C     DATA IMACH(12)/   -128 /
C     DATA IMACH(13)/    127 /
C     DATA IMACH(14)/     39 /
C     DATA IMACH(15)/   -128 /
C     DATA IMACH(16)/    127 /
C
C     MACHINE CONSTANTS FOR THE HP 2100
C     4 WORD DOUBLE PRECISION OPTION WITH FTN4
C
C     DATA IMACH(1) /      5 /
C     DATA IMACH(2) /      6 /
C     DATA IMACH(3) /      4 /
C     DATA IMACH(4) /      1 /
C     DATA IMACH(5) /     16 /
C     DATA IMACH(6) /      2 /
C     DATA IMACH(7) /      2 /
C     DATA IMACH(8) /     15 /
C     DATA IMACH(9) /  32767 /
C     DATA IMACH(10)/      2 /
C     DATA IMACH(11)/     23 /
C     DATA IMACH(12)/   -128 /
C     DATA IMACH(13)/    127 /
C     DATA IMACH(14)/     55 /
C     DATA IMACH(15)/   -128 /
C     DATA IMACH(16)/    127 /
C
C     MACHINE CONSTANTS FOR THE IBM-PC WITH
C     FORTRAN IV-PLUS COMPILER
C
C      DATA IMACH( 1) /    5 /
C      DATA IMACH( 2) /    6 /
C      DATA IMACH( 3) /    5 /
C      DATA IMACH( 4) /    6 /
C      DATA IMACH( 5) /   32 /
C      DATA IMACH( 6) /    4 /
C      DATA IMACH( 7) /    2 /
C      DATA IMACH( 8) /   31 /
C      DATA IMACH( 9) / 2147483647 /
C      DATA IMACH(10) /    2 /
C      DATA IMACH(11) /   23 /
C      DATA IMACH(12) / -126 /
C      DATA IMACH(13) /  127 /
C      DATA IMACH(14) /   52 /
C      DATA IMACH(15) / -1022 /
C      DATA IMACH(16) /  1023/
C
C
C   MACHINE CONSTANTS FOR SUN
C
c      DATA IMACH(1) /     5/
c      DATA IMACH(2) /     6/
c      DATA IMACH(3) /     6/
c      DATA IMACH(4) /     6/
c      DATA IMACH(5) /    32/
c      DATA IMACH(6) /     4/
c     DATA IMACH(7) /     2/
c     DATA IMACH(8) /    31/
c     DATA IMACH(9) /2147483647/
c      DATA IMACH(10) /     2/
c      DATA IMACH(11) /    24/
c      DATA IMACH(12) /  -125/
c      DATA IMACH(13) /   128/
c      DATA IMACH(14) /    53/
c      DATA IMACH(15) / -1021/
c      DATA IMACH(16) /  1024/
C
C   MACHINE CONSTANTS FOR GCC 2.95.2 on x86 JES 02-06-00
C
      DATA IMACH(1) /     5/
      DATA IMACH(2) /     6/
      DATA IMACH(3) /     6/
      DATA IMACH(4) /     6/
      DATA IMACH(5) /    32/
      DATA IMACH(6) /     4/
      DATA IMACH(7) /     2/
      DATA IMACH(8) /    31/
      DATA IMACH(9) /2147483647/
      DATA IMACH(10) /     2/
      DATA IMACH(11) /    24/
      DATA IMACH(12) /  -125/
      DATA IMACH(13) /   128/
      DATA IMACH(14) /    53/
      DATA IMACH(15) / -1021/
      DATA IMACH(16) /  1024/

C
C     MACHINE CONSTANTS FOR THE IBM 360/370 SERIES,
C     THE XEROX SIGMA 5/7/9, THE SEL SYSTEMS 85/86, AND
C     THE PERKIN ELMER (INTERDATA) 7/32.
C
C     DATA IMACH( 1) /   5 /
C     DATA IMACH( 2) /   6 /
C     DATA IMACH( 3) /   7 /
C     DATA IMACH( 4) /   6 /
C     DATA IMACH( 5) /  32 /
C     DATA IMACH( 6) /   4 /
C     DATA IMACH( 7) /   2 /
C     DATA IMACH( 8) /  31 /
C     DATA IMACH( 9) / Z7FFFFFFF /
C     DATA IMACH(10) /  16 /
C     DATA IMACH(11) /   6 /
C     DATA IMACH(12) / -64 /
C     DATA IMACH(13) /  63 /
C     DATA IMACH(14) /  14 /
C     DATA IMACH(15) / -64 /
C     DATA IMACH(16) /  63 /
C
C     MACHINE CONSTANTS FOR THE PDP-10 (KA PROCESSOR).
C
C     DATA IMACH( 1) /    5 /
C     DATA IMACH( 2) /    6 /
C     DATA IMACH( 3) /    5 /
C     DATA IMACH( 4) /    6 /
C     DATA IMACH( 5) /   36 /
C     DATA IMACH( 6) /    5 /
C     DATA IMACH( 7) /    2 /
C     DATA IMACH( 8) /   35 /
C     DATA IMACH( 9) / "377777777777 /
C     DATA IMACH(10) /    2 /
C     DATA IMACH(11) /   27 /
C     DATA IMACH(12) / -128 /
C     DATA IMACH(13) /  127 /
C     DATA IMACH(14) /   54 /
C     DATA IMACH(15) / -101 /
C     DATA IMACH(16) /  127 /
C
C     MACHINE CONSTANTS FOR THE PDP-10 (KI PROCESSOR).
C
C     DATA IMACH( 1) /    5 /
C     DATA IMACH( 2) /    6 /
C     DATA IMACH( 3) /    5 /
C     DATA IMACH( 4) /    6 /
C     DATA IMACH( 5) /   36 /
C     DATA IMACH( 6) /    5 /
C     DATA IMACH( 7) /    2 /
C     DATA IMACH( 8) /   35 /
C     DATA IMACH( 9) / "377777777777 /
C     DATA IMACH(10) /    2 /
C     DATA IMACH(11) /   27 /
C     DATA IMACH(12) / -128 /
C     DATA IMACH(13) /  127 /
C     DATA IMACH(14) /   62 /
C     DATA IMACH(15) / -128 /
C     DATA IMACH(16) /  127 /
C
C     MACHINE CONSTANTS FOR PDP-11 FORTRAN[S SUPPORTING
C     32-BIT INTEGER ARITHMETIC.
C
C     DATA IMACH( 1) /    5 /
C     DATA IMACH( 2) /    6 /
C     DATA IMACH( 3) /    5 /
C     DATA IMACH( 4) /    6 /
C     DATA IMACH( 5) /   32 /
C     DATA IMACH( 6) /    4 /
C     DATA IMACH( 7) /    2 /
C     DATA IMACH( 8) /   31 /
C     DATA IMACH( 9) / 2147483647 /
C     DATA IMACH(10) /    2 /
C     DATA IMACH(11) /   24 /
C     DATA IMACH(12) / -127 /
C     DATA IMACH(13) /  127 /
C     DATA IMACH(14) /   56 /
C     DATA IMACH(15) / -127 /
C     DATA IMACH(16) /  127 /
C
C     MACHINE CONSTANTS FOR PDP-11 FORTRAN[S SUPPORTING
C     16-BIT INTEGER ARITHMETIC.
C
C     DATA IMACH( 1) /    5 /
C     DATA IMACH( 2) /    6 /
C     DATA IMACH( 3) /    5 /
C     DATA IMACH( 4) /    6 /
C     DATA IMACH( 5) /   16 /
C     DATA IMACH( 6) /    2 /
C     DATA IMACH( 7) /    2 /
C     DATA IMACH( 8) /   15 /
C     DATA IMACH( 9) / 32767 /
C     DATA IMACH(10) /    2 /
C     DATA IMACH(11) /   24 /
C     DATA IMACH(12) / -127 /
C     DATA IMACH(13) /  127 /
C     DATA IMACH(14) /   56 /
C     DATA IMACH(15) / -127 /
C     DATA IMACH(16) /  127 /
C
C     MACHINE CONSTANTS FOR THE UNIVAC 1100 SERIES. FTN COMPILER
C
C
C     DATA IMACH( 1) /    5 /
C     DATA IMACH( 2) /    6 /
C     DATA IMACH( 3) /    1 /
C     DATA IMACH( 4) /    6 /
C     DATA IMACH( 5) /   36 /
C     DATA IMACH( 6) /    4 /
C     DATA IMACH( 7) /    2 /
C     DATA IMACH( 8) /   35 /
C     DATA IMACH( 9) / O377777777777 /
C     DATA IMACH(10) /    2 /
C     DATA IMACH(11) /   27 /
C     DATA IMACH(12) / -128 /
C     DATA IMACH(13) /  127 /
C     DATA IMACH(14) /   60 /
C     DATA IMACH(15) /-1024 /
C     DATA IMACH(16) / 1023 /
C
C     MACHINE CONSTANTS FOR THE UNIVAC 1100 SERIES. FOR COMPILER
C
C     DATA IMACH( 1) /    5 /
C     DATA IMACH( 2) /    6 /
C     DATA IMACH( 3) /    7 /
C     DATA IMACH( 4) /    6 /
C     DATA IMACH( 5) /   36 /
C     DATA IMACH( 6) /    6 /
C     DATA IMACH( 7) /    2 /
C     DATA IMACH( 8) /   35 /
C     DATA IMACH( 9) / O377777777777 /
C     DATA IMACH(10) /    2 /
C     DATA IMACH(11) /   27 /
C     DATA IMACH(12) / -128 /
C     DATA IMACH(13) /  127 /
C     DATA IMACH(14) /   60 /
C     DATA IMACH(15) /-1024/
C     DATA IMACH(16) / 1023 /
C
C
C     MACHINE CONSTANTS FOR THE VAX 11/780
C
C     DATA IMACH(1) /    5 /
C     DATA IMACH(2) /    6 /
C     DATA IMACH(3) /    5 /
C     DATA IMACH(4) /    6 /
C     DATA IMACH(5) /   32 /
C     DATA IMACH(6) /    4 /
C     DATA IMACH(7) /    2 /
C     DATA IMACH(8) /   31 /
C     DATA IMACH(9) /2147483647 /
C     DATA IMACH(10)/    2 /
C     DATA IMACH(11)/   24 /
C     DATA IMACH(12)/ -127 /
C     DATA IMACH(13)/  127 /
C     DATA IMACH(14)/   56 /
C     DATA IMACH(15)/ -127 /
C     DATA IMACH(16)/  127 /
C
C***FIRST EXECUTABLE STATEMENT  I1MACH
C
      IF (I .LT. 1  .OR.  I .GT. 16) GO TO 10
C
      I1MACH=IMACH(I)
      RETURN
C
   10 CONTINUE
      WRITE (OUTPUT,9000) I
9000  FORMAT('ERROR IN I1MACH - I OUT OF BOUNDS, I = ',I3)
C
      I1MACH = 0
      STOP
      END
C
      SUBROUTINE DAXPY(N,DA,DX,INCX,DY,INCY)
C***BEGIN PROLOGUE  DAXPY
C***DATE WRITTEN   791001   (YYMMDD)
C***REVISION DATE  820801   (YYMMDD)
C***CATEGORY NO.  D1A7
C***KEYWORDS  BLAS,LINEAR ALGEBRA,VECTOR,TRIAD,DOUBLE PRECISION
C***AUTHOR  LAWSON, C. L., (JPL)
C           HANSON, R. J., (SNLA)
C           KINCAID, D. R., (U. OF TEXAS)
C           KROGH, F. T., (JPL)
C***PURPOSE  D.P COMPUTATION Y = A*X + Y
C***DESCRIPTION
C                B L A S  SUBPROGRAM
C    DESCRIPTION OF PARAMETERS
C
C     --INPUT--
C        N  NUMBER OF ELEMENTS IN INPUT VECTOR(S)
C       DA  DOUBLE PRECISION SCALAR MULTIPLIER
C       DX  DOUBLE PRECISION VECTOR WITH N ELEMENTS
C     INCX  STORAGE SPACING BETWEEN ELEMENTS OF DX
C       DY  DOUBLE PRECISION VECTOR WITH N ELEMENTS
C     INCY  STORAGE SPACING BETWEEN ELEMENTS OF DY
C
C     --OUTPUT--
C       DY  DOUBLE PRECISION RESULT (UNCHANGED IF N .LE. 0)
C
C     OVERWRITE DOUBLE PRECISION DY WITH DOUBLE PRECISION DA*DX + DY.
C     FOR I = 0 TO N-1, REPLACE  DY(LY+I*INCY) WITH DA*DX(LX+I*INCX) +
C       DY(LY+I*INCY), WHERE LX = 1 IF INCX .GE. 0, ELSE LX = (-INCX)*N
C       AND LY IS DEFINED IN A SIMILAR WAY USING INCY.
C***REFERENCES  LAWSON C.L., HANSON R.J., KINCAID D.R., KROGH F.T.,
C                 *BASIC LINEAR ALGEBRA SUBPROGRAMS FOR FORTRAN USAGE*,
C                 ALGORITHM NO. 539, TRANSACTIONS ON MATHEMATICAL
C                 SOFTWARE, VOLUME 5, NUMBER 3, SEPTEMBER 1979, 308-323
C***ROUTINES CALLED  (NONE)
C***END PROLOGUE  DAXPY
C
      DOUBLE PRECISION DX(1),DY(1),DA
C***FIRST EXECUTABLE STATEMENT  DAXPY
      IF(N.LE.0.OR.DA.EQ.0.D0) RETURN
      IF(INCX.EQ.INCY) IF(INCX-1) 5,20,60
    5 CONTINUE
C
C        CODE FOR NONEQUAL OR NONPOSITIVE INCREMENTS.
C
      IX = 1
      IY = 1
      IF(INCX.LT.0)IX = (-N+1)*INCX + 1
      IF(INCY.LT.0)IY = (-N+1)*INCY + 1
      DO 10 I = 1,N
        DY(IY) = DY(IY) + DA*DX(IX)
        IX = IX + INCX
        IY = IY + INCY
   10 CONTINUE
      RETURN
C
C        CODE FOR BOTH INCREMENTS EQUAL TO 1
C
C
C        CLEAN-UP LOOP SO REMAINING VECTOR LENGTH IS A MULTIPLE OF 4.
C
   20 M = MOD(N,4)
      IF( M .EQ. 0 ) GO TO 40
      DO 30 I = 1,M
        DY(I) = DY(I) + DA*DX(I)
   30 CONTINUE
      IF( N .LT. 4 ) RETURN
   40 MP1 = M + 1
      DO 50 I = MP1,N,4
        DY(I) = DY(I) + DA*DX(I)
        DY(I + 1) = DY(I + 1) + DA*DX(I + 1)
        DY(I + 2) = DY(I + 2) + DA*DX(I + 2)
        DY(I + 3) = DY(I + 3) + DA*DX(I + 3)
   50 CONTINUE
      RETURN
C
C        CODE FOR EQUAL, POSITIVE, NONUNIT INCREMENTS.
C
   60 CONTINUE
      NS = N*INCX
          DO 70 I=1,NS,INCX
          DY(I) = DA*DX(I) + DY(I)
   70     CONTINUE
      RETURN
      END
      SUBROUTINE DCFOD(METH,ELCO,TESCO)
C***BEGIN PROLOGUE  DCFOD
C***REFER TO  DDEBDF
C   DCFOD DEFINES COEFFICIENTS NEEDED IN THE INTEGRATOR PACKAGE DDEBDF
C***ROUTINES CALLED  (NONE)
C***END PROLOGUE  DCFOD
C
C
      INTEGER I, IB, METH, NQ, NQM1, NQP1
      DOUBLE PRECISION AGAMQ, DBLE, ELCO, FNQ, FNQM1, PC, PINT, RAGQ,
     *      RQ1FAC, RQFAC, TESCO, TSIGN, XPIN
      DIMENSION ELCO(13,12),TESCO(3,12)
C     ------------------------------------------------------------------
C      DCFOD  IS CALLED BY THE INTEGRATOR ROUTINE TO SET COEFFICIENTS
C      NEEDED THERE.  THE COEFFICIENTS FOR THE CURRENT METHOD, AS
C      GIVEN BY THE VALUE OF METH, ARE SET FOR ALL ORDERS AND SAVED.
C      THE MAXIMUM ORDER ASSUMED HERE IS 12 IF METH = 1 AND 5 IF METH =
C      2.  (A SMALLER VALUE OF THE MAXIMUM ORDER IS ALSO ALLOWED.)
C      DCFOD  IS CALLED ONCE AT THE BEGINNING OF THE PROBLEM,
C      AND IS NOT CALLED AGAIN UNLESS AND UNTIL METH IS CHANGED.
C
C      THE ELCO ARRAY CONTAINS THE BASIC METHOD COEFFICIENTS.
C      THE COEFFICIENTS EL(I), 1 .LE. I .LE. NQ+1, FOR THE METHOD OF
C      ORDER NQ ARE STORED IN ELCO(I,NQ).  THEY ARE GIVEN BY A
C      GENETRATING POLYNOMIAL, I.E.,
C          L(X) = EL(1) + EL(2)*X + ... + EL(NQ+1)*X**NQ.
C      FOR THE IMPLICIT ADAMS METHODS, L(X) IS GIVEN BY
C          DL/DX = (X+1)*(X+2)*...*(X+NQ-1)/FACTORIAL(NQ-1),    L(-1) =
C      0.  FOR THE BDF METHODS, L(X) IS GIVEN BY
C          L(X) = (X+1)*(X+2)* ... *(X+NQ)/K,
C      WHERE         K = FACTORIAL(NQ)*(1 + 1/2 + ... + 1/NQ).
C
C      THE TESCO ARRAY CONTAINS TEST CONSTANTS USED FOR THE
C      LOCAL ERROR TEST AND THE SELECTION OF STEP SIZE AND/OR ORDER.
C      AT ORDER NQ, TESCO(K,NQ) IS USED FOR THE SELECTION OF STEP
C      SIZE AT ORDER NQ - 1 IF K = 1, AT ORDER NQ IF K = 2, AND AT ORDER
C      NQ + 1 IF K = 3.
C     ------------------------------------------------------------------
      DIMENSION PC(12)
C
C***FIRST EXECUTABLE STATEMENT  DCFOD
      GO TO (10,60), METH
C
   10 CONTINUE
         ELCO(1,1) = 1.0D0
         ELCO(2,1) = 1.0D0
         TESCO(1,1) = 0.0D0
         TESCO(2,1) = 2.0D0
         TESCO(1,2) = 1.0D0
         TESCO(3,12) = 0.0D0
         PC(1) = 1.0D0
         RQFAC = 1.0D0
         DO 50 NQ = 2, 12
C           ------------------------------------------------------------
C            THE PC ARRAY WILL CONTAIN THE COEFFICIENTS OF THE
C                POLYNOMIAL P(X) = (X+1)*(X+2)*...*(X+NQ-1).
C            INITIALLY, P(X) = 1.
C           ------------------------------------------------------------
            RQ1FAC = RQFAC
            RQFAC = RQFAC/DBLE(FLOAT(NQ))
            NQM1 = NQ - 1
            FNQM1 = DBLE(FLOAT(NQM1))
            NQP1 = NQ + 1
C           FORM COEFFICIENTS OF P(X)*(X+NQ-1).
C           ----------------------------------
            PC(NQ) = 0.0D0
            DO 20 IB = 1, NQM1
               I = NQP1 - IB
               PC(I) = PC(I-1) + FNQM1*PC(I)
   20       CONTINUE
            PC(1) = FNQM1*PC(1)
C           COMPUTE INTEGRAL, -1 TO 0, OF P(X) AND X*P(X).
C           -----------------------
            PINT = PC(1)
            XPIN = PC(1)/2.0D0
            TSIGN = 1.0D0
            DO 30 I = 2, NQ
               TSIGN = -TSIGN
               PINT = PINT + TSIGN*PC(I)/DBLE(FLOAT(I))
               XPIN = XPIN + TSIGN*PC(I)/DBLE(FLOAT(I+1))
   30       CONTINUE
C           STORE COEFFICIENTS IN ELCO AND TESCO.
C           --------------------------------
            ELCO(1,NQ) = PINT*RQ1FAC
            ELCO(2,NQ) = 1.0D0
            DO 40 I = 2, NQ
               ELCO(I+1,NQ) = RQ1FAC*PC(I)/DBLE(FLOAT(I))
   40       CONTINUE
            AGAMQ = RQFAC*XPIN
            RAGQ = 1.0D0/AGAMQ
            TESCO(2,NQ) = RAGQ
            IF (NQ .LT. 12) TESCO(1,NQP1) = RAGQ*RQFAC/DBLE(FLOAT(NQP1))
            TESCO(3,NQM1) = RAGQ
   50    CONTINUE
      GO TO 100
C
   60 CONTINUE
         PC(1) = 1.0D0
         RQ1FAC = 1.0D0
         DO 90 NQ = 1, 5
C           ------------------------------------------------------------
C            THE PC ARRAY WILL CONTAIN THE COEFFICIENTS OF THE
C                POLYNOMIAL P(X) = (X+1)*(X+2)*...*(X+NQ).
C            INITIALLY, P(X) = 1.
C           ------------------------------------------------------------
            FNQ = DBLE(FLOAT(NQ))
            NQP1 = NQ + 1
C           FORM COEFFICIENTS OF P(X)*(X+NQ).
C           ------------------------------------
            PC(NQP1) = 0.0D0
            DO 70 IB = 1, NQ
               I = NQ + 2 - IB
               PC(I) = PC(I-1) + FNQ*PC(I)
   70       CONTINUE
            PC(1) = FNQ*PC(1)
C           STORE COEFFICIENTS IN ELCO AND TESCO.
C           --------------------------------
            DO 80 I = 1, NQP1
               ELCO(I,NQ) = PC(I)/PC(2)
   80       CONTINUE
            ELCO(2,NQ) = 1.0D0
            TESCO(1,NQ) = RQ1FAC
            TESCO(2,NQ) = DBLE(FLOAT(NQP1))/ELCO(1,NQ)
            TESCO(3,NQ) = DBLE(FLOAT(NQ+2))/ELCO(1,NQ)
            RQ1FAC = RQ1FAC/FNQ
   90    CONTINUE
  100 CONTINUE
      RETURN
C     ----------------------- END OF SUBROUTINE DCFOD
C     -----------------------
      END
      SUBROUTINE DDEBDF(DF,NEQ,T,Y,TOUT,INFO,RTOL,ATOL,IDID,RWORK,LRW,
     *                  IWORK,LIW,RPAR,IPAR,DJAC)
C***BEGIN PROLOGUE  DDEBDF
C***DATE WRITTEN   820301   (YYMMDD)
C***REVISION DATE  830630   (YYMMDD)
C***CATEGORY NO.  I1A2
C***KEYWORDS  ODE,STIFF,ORDINARY DIFFERENTIAL EQUATIONS,DEPAC,
C             INITIAL VALUE PROBLEMS,BACKWARD DIFFERENTIATION FORMULAS,
C             DOUBLE PRECISION
C***AUTHOR  SHAMPINE L.F.
C           WATTS H.A.
C***PURPOSE  SOLVES INITIAL VALUE PROBLEMS IN ORDINARY DIFFERENTIAL
C            EQUATIONS USING BACKWARD DIFFERENTIATION FORMULAE.  IT IS
C            INTENDED PRIMARILY FOR STIFF PROBLEMS.
C***DESCRIPTION
C   THIS IS THE BACKWARD DIFFERENTIATION CODE IN THE PACKAGE OF
C   DIFFERENTIAL EQUATION SOLVERS DEPAC, CONSISTING OF THE CODES
C   DDERKF, DDEABM, AND DDEBDF. DESIGN OF THE PACKAGE WAS BY L. F.
C   SHAMPINE AND H. A. WATTS. IT IS DOCUMENTED IN
C        SAND79-2374 , DEPAC - DESIGN OF A USER ORIENTED PACKAGE OF ODE
C                              SOLVERS.
C   DDEBDF IS A DRIVER FOR A MODIFICATION OF THE CODE LSODE WRITTEN BY
C             A. C. HINDMARSH
C             LAWRENCE LIVERMORE LABORATORY
C             LIVERMORE, CALIFORNIA 94550
C
C * ABSTRACT *
C ************
C
C   SUBROUTINE DDEBDF USES THE BACKWARD DIFFERENTIATION FORMULAS OF
C   ORDERS ONE THROUGH FIVE TO INTEGRATE A SYSTEM OF NEQ FIRST ORDER
C   ORDINARY DIFFERENTIAL EQUATIONS OF THE FORM
C                         DU/DX = DF(X,U)
C   WHEN THE VECTOR Y(*) OF INITIAL VALUES FOR U(*) AT X=T IS GIVEN.
C   THE SUBROUTINE INTEGRATES FROM T TO TOUT. IT IS EASY TO CONTINUE THE
C   INTEGRATION TO GET RESULTS AT ADDITIONAL TOUT. THIS IS THE INTERVAL
C   MODE OF OPERATION. IT IS ALSO EASY FOR THE ROUTINE TO RETURN WITH
C   THE SOLUTION AT EACH INTERMEDIATE STEP ON THE WAY TO TOUT. THIS IS
C   THE INTERMEDIATE-OUTPUT MODE OF OPERATION.
C
C   DDEBDF USES SUBPROGRAMS DLSOD, DINTYD, DSTOD, DCFOD, DPJAC, DSLVS,
C   DVNRMS, DHSTRT, DVNORM, DSVCO, DRSCO, D1MACH, AND THE LINPACK
C   ROUTINES DGEFA, DGESL, DGBFA, DGBSL (WHICH ALSO USES THE BLAS
C   ROUTINES DAXPY, DSCAL, IDAMAX AND DDOT) AND THE ERROR HANDLING
C   ROUTINE XERRWV.  THE ONLY MACHINE DEPENDENT PARAMETERS TO BE
C   ASSIGNED APPEAR IN D1MACH.
C
C **********************************************************************
C * DESCRIPTION OF THE ARGUMENTS TO DDEBDF (AN OVERVIEW) *
C **********************************************************************
C
C   THE PARAMETERS ARE
C
C      DF -- THIS IS THE NAME OF A SUBROUTINE WHICH YOU PROVIDE TO
C             DEFINE THE DIFFERENTIAL EQUATIONS.
C
C      NEQ -- THIS IS THE NUMBER OF (FIRST ORDER) DIFFERENTIAL
C             EQUATIONS TO BE INTEGRATED.
C
C      T -- THIS IS A VALUE OF THE INDEPENDENT VARIABLE.
C
C      Y(*) -- THIS ARRAY CONTAINS THE SOLUTION COMPONENTS AT T.
C
C      TOUT -- THIS IS A POINT AT WHICH A SOLUTION IS DESIRED.
C
C      INFO(*) -- THE BASIC TASK OF THE CODE IS TO INTEGRATE THE
C             DIFFERENTIAL EQUATIONS FROM T TO TOUT AND RETURN AN
C             ANSWER AT TOUT. INFO(*) IS AN INTEGER ARRAY WHICH IS USED
C             TO COMMUNICATE EXACTLY HOW YOU WANT THIS TASK TO BE
C             CARRIED OUT.
C
C      RTOL, ATOL -- THESE QUANTITIES REPRESENT RELATIVE AND ABSOLUTE
C             ERROR TOLERANCES WHICH YOU PROVIDE TO INDICATE HOW
C             ACCURATELY YOU WISH THE SOLUTION TO BE COMPUTED. YOU MAY
C             CHOOSE THEM TO BE BOTH SCALARS OR ELSE BOTH VECTORS.
C
C      IDID -- THIS SCALAR QUANTITY IS AN INDICATOR REPORTING WHAT
C             THE CODE DID. YOU MUST MONITOR THIS INTEGER VARIABLE TO
C             DECIDE WHAT ACTION TO TAKE NEXT.
C
C      RWORK(*), LRW -- RWORK(*) IS A DOUBLE PRECISION WORK ARRAY OF
C             LENGTH LRW WHICH PROVIDES THE CODE WITH NEEDED STORAGE
C             SPACE.
C
C      IWORK(*), LIW -- IWORK(*) IS AN INTEGER WORK ARRAY OF LENGTH LIW
C             WHICH PROVIDES THE CODE WITH NEEDED STORAGE SPACE.
C
C      RPAR, IPAR -- THESE ARE DOUBLE PRECISION AND INTEGER PARAMETER
C             ARRAYS WHICH YOU CAN USE FOR COMMUNICATION BETWEEN YOUR
C             CALLING PROGRAM AND THE DF SUBROUTINE (AND THE DJAC
C             SUBROUTINE).
C
C      DJAC -- THIS IS THE NAME OF A SUBROUTINE WHICH YOU MAY CHOOSE TO
C             PROVIDE FOR DEFINING THE JACOBIAN MATRIX OF PARTIAL
C             DERIVATIVES DF/DU.
C
C  QUANTITIES WHICH ARE USED AS INPUT ITEMS ARE
C             NEQ, T, Y(*), TOUT, INFO(*),
C             RTOL, ATOL, RWORK(1), LRW,
C             IWORK(1), IWORK(2), AND LIW.
C
C  QUANTITIES WHICH MAY BE ALTERED BY THE CODE ARE
C             T, Y(*), INFO(1), RTOL, ATOL,
C             IDID, RWORK(*) AND IWORK(*).
C
C **********************************************************************
C * INPUT -- WHAT TO DO ON THE FIRST CALL TO DDEBDF *
C **********************************************************************
C
C   THE FIRST CALL OF THE CODE IS DEFINED TO BE THE START OF EACH NEW
C   PROBLEM. READ THROUGH THE DESCRIPTIONS OF ALL THE FOLLOWING ITEMS,
C   PROVIDE SUFFICIENT STORAGE SPACE FOR DESIGNATED ARRAYS, SET
C   APPROPRIATE VARIABLES FOR THE INITIALIZATION OF THE PROBLEM, AND
C   GIVE INFORMATION ABOUT HOW YOU WANT THE PROBLEM TO BE SOLVED.
C
C
C      DF -- PROVIDE A SUBROUTINE OF THE FORM
C                               DF(X,U,UPRIME,RPAR,IPAR)
C             TO DEFINE THE SYSTEM OF FIRST ORDER DIFFERENTIAL EQUATIONS
C             WHICH IS TO BE SOLVED. FOR THE GIVEN VALUES OF X AND THE
C             VECTOR  U(*)=(U(1),U(2),...,U(NEQ)) , THE SUBROUTINE MUST
C             EVALUATE THE NEQ COMPONENTS OF THE SYSTEM OF DIFFERENTIAL
C             EQUATIONS  DU/DX=DF(X,U)  AND STORE THE DERIVATIVES IN THE
C             ARRAY UPRIME(*), THAT IS,  UPRIME(I) = * DU(I)/DX *  FOR
C             EQUATIONS I=1,...,NEQ.
C
C             SUBROUTINE DF MUST NOT ALTER X OR U(*). YOU MUST DECLARE
C             THE NAME DF IN AN EXTERNAL STATEMENT IN YOUR PROGRAM THAT
C             CALLS DDEBDF. YOU MUST DIMENSION U AND UPRIME IN DF.
C
C             RPAR AND IPAR ARE DOUBLE PRECISION AND INTEGER PARAMETER
C             ARRAYS WHICH YOU CAN USE FOR COMMUNICATION BETWEEN YOUR
C             CALLING PROGRAM AND SUBROUTINE DF. THEY ARE NOT USED OR
C             ALTERED BY DDEBDF.  IF YOU DO NOT NEED RPAR OR IPAR,
C             IGNORE THESE PARAMETERS BY TREATING THEM AS DUMMY
C             ARGUMENTS. IF YOU DO CHOOSE TO USE THEM, DIMENSION THEM IN
C             YOUR CALLING PROGRAM AND IN DF AS ARRAYS OF APPROPRIATE
C             LENGTH.
C
C      NEQ -- SET IT TO THE NUMBER OF DIFFERENTIAL EQUATIONS.
C             (NEQ .GE. 1)
C
C      T -- SET IT TO THE INITIAL POINT OF THE INTEGRATION.
C             YOU MUST USE A PROGRAM VARIABLE FOR T BECAUSE THE CODE
C             CHANGES ITS VALUE.
C
C      Y(*) -- SET THIS VECTOR TO THE INITIAL VALUES OF THE NEQ SOLUTION
C             COMPONENTS AT THE INITIAL POINT. YOU MUST DIMENSION Y AT
C             LEAST NEQ IN YOUR CALLING PROGRAM.
C
C      TOUT -- SET IT TO THE FIRST POINT AT WHICH A SOLUTION
C             IS DESIRED. YOU CAN TAKE TOUT = T, IN WHICH CASE THE CODE
C             WILL EVALUATE THE DERIVATIVE OF THE SOLUTION AT T AND
C             RETURN. INTEGRATION EITHER FORWARD IN T  (TOUT .GT. T)  OR
C             BACKWARD IN T  (TOUT .LT. T)  IS PERMITTED.
C
C             THE CODE ADVANCES THE SOLUTION FROM T TO TOUT USING
C             STEP SIZES WHICH ARE AUTOMATICALLY SELECTED SO AS TO
C             ACHIEVE THE DESIRED ACCURACY. IF YOU WISH, THE CODE WILL
C             RETURN WITH THE SOLUTION AND ITS DERIVATIVE FOLLOWING
C             EACH INTERMEDIATE STEP (INTERMEDIATE-OUTPUT MODE) SO THAT
C             YOU CAN MONITOR THEM, BUT YOU STILL MUST PROVIDE TOUT IN
C             ACCORD WITH THE BASIC AIM OF THE CODE.
C
C             THE FIRST STEP TAKEN BY THE CODE IS A CRITICAL ONE
C             BECAUSE IT MUST REFLECT HOW FAST THE SOLUTION CHANGES NEAR
C             THE INITIAL POINT. THE CODE AUTOMATICALLY SELECTS AN
C             INITIAL STEP SIZE WHICH IS PRACTICALLY ALWAYS SUITABLE FOR
C             THE PROBLEM. BY USING THE FACT THAT THE CODE WILL NOT STEP
C             PAST TOUT IN THE FIRST STEP, YOU COULD, IF NECESSARY,
C             RESTRICT THE LENGTH OF THE INITIAL STEP SIZE.
C
C             FOR SOME PROBLEMS IT MAY NOT BE PERMISSIBLE TO INTEGRATE
C             PAST A POINT TSTOP BECAUSE A DISCONTINUITY OCCURS THERE
C             OR THE SOLUTION OR ITS DERIVATIVE IS NOT DEFINED BEYOND
C             TSTOP. WHEN YOU HAVE DECLARED A TSTOP POINT (SEE INFO(4)
C             AND RWORK(1)), YOU HAVE TOLD THE CODE NOT TO INTEGRATE
C             PAST TSTOP. IN THIS CASE ANY TOUT BEYOND TSTOP IS INVALID
C             INPUT.
C
C      INFO(*) -- USE THE INFO ARRAY TO GIVE THE CODE MORE DETAILS ABOUT
C             HOW YOU WANT YOUR PROBLEM SOLVED. THIS ARRAY SHOULD BE
C             DIMENSIONED OF LENGTH 15 TO ACCOMODATE OTHER MEMBERS OF
C             DEPAC OR POSSIBLE FUTURE EXTENSIONS, THOUGH DDEBDF USES
C             ONLY THE FIRST SIX ENTRIES. YOU MUST RESPOND TO ALL OF
C             THE FOLLOWING ITEMS WHICH ARE ARRANGED AS QUESTIONS. THE
C             SIMPLEST USE OF THE CODE CORRESPONDS TO ANSWERING ALL
C             QUESTIONS AS YES ,I.E. SETTING ALL ENTRIES OF INFO TO 0.
C
C        INFO(1) -- THIS PARAMETER ENABLES THE CODE TO INITIALIZE
C               ITSELF. YOU MUST SET IT TO INDICATE THE START OF EVERY
C               NEW PROBLEM.
C
C            **** IS THIS THE FIRST CALL FOR THIS PROBLEM ...
C                  YES -- SET INFO(1) = 0
C                   NO -- NOT APPLICABLE HERE.
C                         SEE BELOW FOR CONTINUATION CALLS.  ****
C
C        INFO(2) -- HOW MUCH ACCURACY YOU WANT OF YOUR SOLUTION
C               IS SPECIFIED BY THE ERROR TOLERANCES RTOL AND ATOL.
C               THE SIMPLEST USE IS TO TAKE THEM BOTH TO BE SCALARS.
C               TO OBTAIN MORE FLEXIBILITY, THEY CAN BOTH BE VECTORS.
C               THE CODE MUST BE TOLD YOUR CHOICE.
C
C            **** ARE BOTH ERROR TOLERANCES RTOL, ATOL SCALARS ...
C                  YES -- SET INFO(2) = 0
C                         AND INPUT SCALARS FOR BOTH RTOL AND ATOL
C                   NO -- SET INFO(2) = 1
C                         AND INPUT ARRAYS FOR BOTH RTOL AND ATOL ****
C
C        INFO(3) -- THE CODE INTEGRATES FROM T IN THE DIRECTION
C               OF TOUT BY STEPS. IF YOU WISH, IT WILL RETURN THE
C               COMPUTED SOLUTION AND DERIVATIVE AT THE NEXT
C               INTERMEDIATE STEP (THE INTERMEDIATE-OUTPUT MODE) OR
C               TOUT, WHICHEVER COMES FIRST. THIS IS A GOOD WAY TO
C               PROCEED IF YOU WANT TO SEE THE BEHAVIOR OF THE SOLUTION.
C               IF YOU MUST HAVE SOLUTIONS AT A GREAT MANY SPECIFIC
C               TOUT POINTS, THIS CODE WILL COMPUTE THEM EFFICIENTLY.
C
C            **** DO YOU WANT THE SOLUTION ONLY AT
C                 TOUT (AND NOT AT THE NEXT INTERMEDIATE STEP) ...
C                  YES -- SET INFO(3) = 0
C                   NO -- SET INFO(3) = 1 ****
C
C        INFO(4) -- TO HANDLE SOLUTIONS AT A GREAT MANY SPECIFIC
C               VALUES TOUT EFFICIENTLY, THIS CODE MAY INTEGRATE PAST
C               TOUT AND INTERPOLATE TO OBTAIN THE RESULT AT TOUT.
C               SOMETIMES IT IS NOT POSSIBLE TO INTEGRATE BEYOND SOME
C               POINT TSTOP BECAUSE THE EQUATION CHANGES THERE OR IT IS
C               NOT DEFINED PAST TSTOP. THEN YOU MUST TELL THE CODE
C               NOT TO GO PAST.
C
C            **** CAN THE INTEGRATION BE CARRIED OUT WITHOUT ANY
C                 RESTRICTIONS ON THE INDEPENDENT VARIABLE T ...
C                  YES -- SET INFO(4)=0
C                   NO -- SET INFO(4)=1
C                         AND DEFINE THE STOPPING POINT TSTOP BY
C                         SETTING RWORK(1)=TSTOP ****
C
C        INFO(5) -- TO SOLVE STIFF PROBLEMS IT IS NECESSARY TO USE THE
C               JACOBIAN MATRIX OF PARTIAL DERIVATIVES OF THE SYSTEM
C               OF DIFFERENTIAL EQUATIONS. IF YOU DO NOT PROVIDE A
C               SUBROUTINE TO EVALUATE IT ANALYTICALLY (SEE THE
C               DESCRIPTION OF THE ITEM DJAC IN THE CALL LIST), IT WILL
C               BE APPROXIMATED BY NUMERICAL DIFFERENCING IN THIS CODE.
C               ALTHOUGH IT IS LESS TROUBLE FOR YOU TO HAVE THE CODE
C               COMPUTE PARTIAL DERIVATIVES BY NUMERICAL DIFFERENCING,
C               THE SOLUTION WILL BE MORE RELIABLE IF YOU PROVIDE THE
C               DERIVATIVES VIA DJAC. SOMETIMES NUMERICAL DIFFERENCING
C               IS CHEAPER THAN EVALUATING DERIVATIVES IN DJAC AND
C               SOMETIMES IT IS NOT - THIS DEPENDS ON YOUR PROBLEM.
C
C               IF YOUR PROBLEM IS LINEAR, I.E. HAS THE FORM
C               DU/DX = DF(X,U) = J(X)*U + G(X)   FOR SOME MATRIX J(X)
C               AND VECTOR G(X), THE JACOBIAN MATRIX  DF/DU = J(X).
C               SINCE YOU MUST PROVIDE A SUBROUTINE TO EVALUATE DF(X,U)
C               ANALYTICALLY, IT IS LITTLE EXTRA TROUBLE TO PROVIDE
C               SUBROUTINE DJAC FOR EVALUATING J(X) ANALYTICALLY.
C               FURTHERMORE, IN SUCH CASES, NUMERICAL DIFFERENCING IS
C               MUCH MORE EXPENSIVE THAN ANALYTIC EVALUATION.
C
C            **** DO YOU WANT THE CODE TO EVALUATE THE PARTIAL
C                 DERIVATIVES AUTOMATICALLY BY NUMERICAL DIFFERENCES ...
C                  YES -- SET INFO(5)=0
C                   NO -- SET INFO(5)=1
C                         AND PROVIDE SUBROUTINE DJAC FOR EVALUATING THE
C                         JACOBIAN MATRIX ****
C
C        INFO(6) -- DDEBDF WILL PERFORM MUCH BETTER IF THE JACOBIAN
C               MATRIX IS BANDED AND THE CODE IS TOLD THIS. IN THIS
C               CASE, THE STORAGE NEEDED WILL BE GREATLY REDUCED,
C               NUMERICAL DIFFERENCING WILL BE PERFORMED MORE CHEAPLY,
C               AND A NUMBER OF IMPORTANT ALGORITHMS WILL EXECUTE MUCH
C               FASTER. THE DIFFERENTIAL EQUATION IS SAID TO HAVE
C               HALF-BANDWIDTHS ML (LOWER) AND MU (UPPER) IF EQUATION I
C               INVOLVES ONLY UNKNOWNS Y(J) WITH
C                              I-ML .LE. J .LE. I+MU
C               FOR ALL I=1,2,...,NEQ. THUS, ML AND MU ARE THE WIDTHS
C               OF THE LOWER AND UPPER PARTS OF THE BAND, RESPECTIVELY,
C               WITH THE MAIN DIAGONAL BEING EXCLUDED. IF YOU DO NOT
C               INDICATE THAT THE EQUATION HAS A BANDED JACOBIAN,
C               THE CODE WORKS WITH A FULL MATRIX OF NEQ**2 ELEMENTS
C               (STORED IN THE CONVENTIONAL WAY). COMPUTATIONS WITH
C               BANDED MATRICES COST LESS TIME AND STORAGE THAN WITH
C               FULL MATRICES IF  2*ML+MU .LT. NEQ.  IF YOU TELL THE
C               CODE THAT THE JACOBIAN MATRIX HAS A BANDED STRUCTURE AND
C               YOU WANT TO PROVIDE SUBROUTINE DJAC TO COMPUTE THE
C               PARTIAL DERIVATIVES, THEN YOU MUST BE CAREFUL TO STORE
C               THE ELEMENTS OF THE JACOBIAN MATRIX IN THE SPECIAL FORM
C               INDICATED IN THE DESCRIPTION OF DJAC.
C
C            **** DO YOU WANT TO SOLVE THE PROBLEM USING A FULL
C                 (DENSE) JACOBIAN MATRIX (AND NOT A SPECIAL BANDED
C                 STRUCTURE) ...
C                  YES -- SET INFO(6)=0
C                   NO -- SET INFO(6)=1
C                         AND PROVIDE THE LOWER (ML) AND UPPER (MU)
C                         BANDWIDTHS BY SETTING
C                         IWORK(1)=ML
C                         IWORK(2)=MU ****
C
C      RTOL, ATOL -- YOU MUST ASSIGN RELATIVE (RTOL) AND ABSOLUTE (ATOL)
C             ERROR TOLERANCES TO TELL THE CODE HOW ACCURATELY YOU WANT
C             THE SOLUTION TO BE COMPUTED. THEY MUST BE DEFINED AS
C             PROGRAM VARIABLES BECAUSE THE CODE MAY CHANGE THEM. YOU
C             HAVE TWO CHOICES --
C                  BOTH RTOL AND ATOL ARE SCALARS. (INFO(2)=0)
C                  BOTH RTOL AND ATOL ARE VECTORS. (INFO(2)=1)
C             IN EITHER CASE ALL COMPONENTS MUST BE NON-NEGATIVE.
C
C             THE TOLERANCES ARE USED BY THE CODE IN A LOCAL ERROR TEST
C             AT EACH STEP WHICH REQUIRES ROUGHLY THAT
C                     ABS(LOCAL ERROR) .LE. RTOL*ABS(Y)+ATOL
C             FOR EACH VECTOR COMPONENT.
C             (MORE SPECIFICALLY, A ROOT-MEAN-SQUARE NORM IS USED TO
C             MEASURE THE SIZE OF VECTORS, AND THE ERROR TEST USES THE
C             MAGNITUDE OF THE SOLUTION AT THE BEGINNING OF THE STEP.)
C
C             THE TRUE (GLOBAL) ERROR IS THE DIFFERENCE BETWEEN THE TRUE
C             SOLUTION OF THE INITIAL VALUE PROBLEM AND THE COMPUTED
C             APPROXIMATION. PRACTICALLY ALL PRESENT DAY CODES,
C             INCLUDING THIS ONE, CONTROL THE LOCAL ERROR AT EACH STEP
C             AND DO NOT EVEN ATTEMPT TO CONTROL THE GLOBAL ERROR
C             DIRECTLY. ROUGHLY SPEAKING, THEY PRODUCE A SOLUTION Y(T)
C             WHICH SATISFIES THE DIFFERENTIAL EQUATIONS WITH A
C             RESIDUAL R(T),    DY(T)/DT = DF(T,Y(T)) + R(T)   ,
C             AND, ALMOST ALWAYS, R(T) IS BOUNDED BY THE ERROR
C             TOLERANCES. USUALLY, BUT NOT ALWAYS, THE TRUE ACCURACY OF
C             THE COMPUTED Y IS COMPARABLE TO THE ERROR TOLERANCES. THIS
C             CODE WILL USUALLY, BUT NOT ALWAYS, DELIVER A MORE ACCURATE
C             SOLUTION IF YOU REDUCE THE TOLERANCES AND INTEGRATE AGAIN.
C             BY COMPARING TWO SUCH SOLUTIONS YOU CAN GET A FAIRLY
C             RELIABLE IDEA OF THE TRUE ERROR IN THE SOLUTION AT THE
C             BIGGER TOLERANCES.
C
C             SETTING ATOL=0. RESULTS IN A PURE RELATIVE ERROR TEST ON
C             THAT COMPONENT. SETTING RTOL=0. RESULTS IN A PURE ABSOLUTE
C             ERROR TEST ON THAT COMPONENT. A MIXED TEST WITH NON-ZERO
C             RTOL AND ATOL CORRESPONDS ROUGHLY TO A RELATIVE ERROR
C             TEST WHEN THE SOLUTION COMPONENT IS MUCH BIGGER THAN ATOL
C             AND TO AN ABSOLUTE ERROR TEST WHEN THE SOLUTION COMPONENT
C             IS SMALLER THAN THE THRESHOLD ATOL.
C
C             PROPER SELECTION OF THE ABSOLUTE ERROR CONTROL PARAMETERS
C             ATOL  REQUIRES YOU TO HAVE SOME IDEA OF THE SCALE OF THE
C             SOLUTION COMPONENTS. TO ACQUIRE THIS INFORMATION MAY MEAN
C             THAT YOU WILL HAVE TO SOLVE THE PROBLEM MORE THAN ONCE. IN
C             THE ABSENCE OF SCALE INFORMATION, YOU SHOULD ASK FOR SOME
C             RELATIVE ACCURACY IN ALL THE COMPONENTS (BY SETTING  RTOL
C             VALUES NON-ZERO) AND PERHAPS IMPOSE EXTREMELY SMALL
C             ABSOLUTE ERROR TOLERANCES TO PROTECT AGAINST THE DANGER OF
C             A SOLUTION COMPONENT BECOMING ZERO.
C
C             THE CODE WILL NOT ATTEMPT TO COMPUTE A SOLUTION AT AN
C             ACCURACY UNREASONABLE FOR THE MACHINE BEING USED. IT WILL
C             ADVISE YOU IF YOU ASK FOR TOO MUCH ACCURACY AND INFORM
C             YOU AS TO THE MAXIMUM ACCURACY IT BELIEVES POSSIBLE.
C
C      RWORK(*) -- DIMENSION THIS DOUBLE PRECISION WORK ARRAY OF LENGTH
C             LRW IN YOUR CALLING PROGRAM.
C
C      RWORK(1) -- IF YOU HAVE SET INFO(4)=0, YOU CAN IGNORE THIS
C             OPTIONAL INPUT PARAMETER. OTHERWISE YOU MUST DEFINE A
C             STOPPING POINT TSTOP BY SETTING   RWORK(1) = TSTOP.
C             (FOR SOME PROBLEMS IT MAY NOT BE PERMISSIBLE TO INTEGRATE
C             PAST A POINT TSTOP BECAUSE A DISCONTINUITY OCCURS THERE
C             OR THE SOLUTION OR ITS DERIVATIVE IS NOT DEFINED BEYOND
C             TSTOP.)
C
C      LRW -- SET IT TO THE DECLARED LENGTH OF THE RWORK ARRAY.
C             YOU MUST HAVE
C                  LRW .GE. 250+10*NEQ+NEQ**2
C             FOR THE FULL (DENSE) JACOBIAN CASE (WHEN INFO(6)=0),  OR
C                  LRW .GE. 250+10*NEQ+(2*ML+MU+1)*NEQ
C             FOR THE BANDED JACOBIAN CASE (WHEN INFO(6)=1).
C
C      IWORK(*) -- DIMENSION THIS INTEGER WORK ARRAY OF LENGTH LIW IN
C             YOUR CALLING PROGRAM.
C
C      IWORK(1), IWORK(2) -- IF YOU HAVE SET INFO(6)=0, YOU CAN IGNORE
C             THESE OPTIONAL INPUT PARAMETERS. OTHERWISE YOU MUST DEFINE
C             THE HALF-BANDWIDTHS ML (LOWER) AND MU (UPPER) OF THE
C             JACOBIAN MATRIX BY SETTING    IWORK(1) = ML   AND
C             IWORK(2) = MU.  (THE CODE WILL WORK WITH A FULL MATRIX
C             OF NEQ**2 ELEMENTS UNLESS IT IS TOLD THAT THE PROBLEM HAS
C             A BANDED JACOBIAN, IN WHICH CASE THE CODE WILL WORK WITH
C             A MATRIX CONTAINING AT MOST  (2*ML+MU+1)*NEQ  ELEMENTS.)
C
C      LIW -- SET IT TO THE DECLARED LENGTH OF THE IWORK ARRAY.
C             YOU MUST HAVE LIW .GE. 55+NEQ.
C
C      RPAR, IPAR -- THESE ARE PARAMETER ARRAYS, OF DOUBLE PRECISION AND
C             INTEGER TYPE, RESPECTIVELY. YOU CAN USE THEM FOR
C             COMMUNICATION BETWEEN YOUR PROGRAM THAT CALLS DDEBDF AND
C             THE  DF SUBROUTINE (AND THE DJAC SUBROUTINE). THEY ARE NOT
C             USED OR ALTERED BY DDEBDF. IF YOU DO NOT NEED RPAR OR
C             IPAR, IGNORE THESE PARAMETERS BY TREATING THEM AS DUMMY
C             ARGUMENTS. IF YOU DO CHOOSE TO USE THEM, DIMENSION THEM IN
C             YOUR CALLING PROGRAM AND IN DF (AND IN DJAC) AS ARRAYS OF
C             APPROPRIATE LENGTH.
C
C      DJAC -- IF YOU HAVE SET INFO(5)=0, YOU CAN IGNORE THIS PARAMETER
C             BY TREATING IT AS A DUMMY ARGUMENT. (FOR SOME COMPILERS
C             YOU MAY HAVE TO WRITE A DUMMY SUBROUTINE NAMED  DJAC  IN
C             ORDER TO AVOID PROBLEMS ASSOCIATED WITH MISSING EXTERNAL
C             ROUTINE NAMES.)  OTHERWISE, YOU MUST PROVIDE A SUBROUTINE
C             OF THE FORM
C                          DJAC(X,U,PD,NROWPD,RPAR,IPAR)
C             TO DEFINE THE JACOBIAN MATRIX OF PARTIAL DERIVATIVES DF/DU
C             OF THE SYSTEM OF DIFFERENTIAL EQUATIONS   DU/DX = DF(X,U).
C             FOR THE GIVEN VALUES OF X AND THE VECTOR
C             U(*)=(U(1),U(2),...,U(NEQ)), THE SUBROUTINE MUST EVALUATE
C             THE NON-ZERO PARTIAL DERIVATIVES  DF(I)/DU(J)  FOR EACH
C             DIFFERENTIAL EQUATION I=1,...,NEQ AND EACH SOLUTION
C             COMPONENT J=1,...,NEQ , AND STORE THESE VALUES IN THE
C             MATRIX PD. THE ELEMENTS OF PD ARE SET TO ZERO BEFORE EACH
C             CALL TO DJAC SO ONLY NON-ZERO ELEMENTS NEED TO BE DEFINED.
C
C             SUBROUTINE DJAC MUST NOT ALTER X, U(*), OR NROWPD. YOU
C             MUST DECLARE THE NAME DJAC IN AN EXTERNAL STATEMENT IN
C             YOUR PROGRAM THAT CALLS DDEBDF. NROWPD IS THE ROW
C             DIMENSION OF THE PD MATRIX AND IS ASSIGNED BY THE CODE.
C             THEREFORE YOU MUST DIMENSION PD IN DJAC ACCORDING TO
C                              DIMENSION PD(NROWPD,1)
C             YOU MUST ALSO DIMENSION U IN DJAC.
C
C             THE WAY YOU MUST STORE THE ELEMENTS INTO THE PD MATRIX
C             DEPENDS ON THE STRUCTURE OF THE JACOBIAN WHICH YOU
C             INDICATED BY INFO(6).
C             *** INFO(6)=0 -- FULL (DENSE) JACOBIAN ***
C                 WHEN YOU EVALUATE THE (NON-ZERO) PARTIAL DERIVATIVE
C                 OF EQUATION I WITH RESPECT TO VARIABLE J, YOU MUST
C                 STORE IT IN PD ACCORDING TO
C                                PD(I,J) = * DF(I)/DU(J) *
C             *** INFO(6)=1 -- BANDED JACOBIAN WITH ML LOWER AND MU
C                 UPPER DIAGONAL BANDS (REFER TO INFO(6) DESCRIPTION OF
C                 ML AND MU) ***
C                 WHEN YOU EVALUATE THE (NON-ZERO) PARTIAL DERIVATIVE
C                 OF EQUATION I WITH RESPECT TO VARIABLE J, YOU MUST
C                 STORE IT IN PD ACCORDING TO
C                                IROW = I - J + ML + MU + 1
C                                PD(IROW,J) = * DF(I)/DU(J) *
C
C             RPAR AND IPAR ARE DOUBLE PRECISION AND INTEGER PARAMETER
C             ARRAYS WHICH YOU CAN USE FOR COMMUNICATION BETWEEN YOUR
C             CALLING PROGRAM AND YOUR JACOBIAN SUBROUTINE DJAC. THEY
C             ARE NOT ALTERED BY DDEBDF. IF YOU DO NOT NEED RPAR OR
C             IPAR, IGNORE THESE PARAMETERS BY TREATING THEM AS DUMMY
C             ARGUMENTS. IF YOU DO CHOOSE TO USE THEM, DIMENSION THEM IN
C             YOUR CALLING PROGRAM AND IN DJAC AS ARRAYS OF APPROPRIATE
C             LENGTH.
C
C **********************************************************************
C * OUTPUT -- AFTER ANY RETURN FROM DDEBDF *
C **********************************************************************
C
C   THE PRINCIPAL AIM OF THE CODE IS TO RETURN A COMPUTED SOLUTION AT
C   TOUT, ALTHOUGH IT IS ALSO POSSIBLE TO OBTAIN INTERMEDIATE RESULTS
C   ALONG THE WAY. TO FIND OUT WHETHER THE CODE ACHIEVED ITS GOAL
C   OR IF THE INTEGRATION PROCESS WAS INTERRUPTED BEFORE THE TASK WAS
C   COMPLETED, YOU MUST CHECK THE IDID PARAMETER.
C
C
C      T -- THE SOLUTION WAS SUCCESSFULLY ADVANCED TO THE
C             OUTPUT VALUE OF T.
C
C      Y(*) -- CONTAINS THE COMPUTED SOLUTION APPROXIMATION AT T.
C             YOU MAY ALSO BE INTERESTED IN THE APPROXIMATE DERIVATIVE
C             OF THE SOLUTION AT T. IT IS CONTAINED IN
C             RWORK(21),...,RWORK(20+NEQ).
C
C      IDID -- REPORTS WHAT THE CODE DID
C
C                         *** TASK COMPLETED ***
C                   REPORTED BY POSITIVE VALUES OF IDID
C
C             IDID = 1 -- A STEP WAS SUCCESSFULLY TAKEN IN THE
C                       INTERMEDIATE-OUTPUT MODE. THE CODE HAS NOT
C                       YET REACHED TOUT.
C
C             IDID = 2 -- THE INTEGRATION TO TOUT WAS SUCCESSFULLY
C                       COMPLETED (T=TOUT) BY STEPPING EXACTLY TO TOUT.
C
C             IDID = 3 -- THE INTEGRATION TO TOUT WAS SUCCESSFULLY
C                       COMPLETED (T=TOUT) BY STEPPING PAST TOUT.
C                       Y(*) IS OBTAINED BY INTERPOLATION.
C
C                         *** TASK INTERRUPTED ***
C                   REPORTED BY NEGATIVE VALUES OF IDID
C
C             IDID = -1 -- A LARGE AMOUNT OF WORK HAS BEEN EXPENDED.
C                       (5000 STEPS ATTEMPTED)
C
C             IDID = -2 -- THE ERROR TOLERANCES ARE TOO STRINGENT.
C
C             IDID = -3 -- THE LOCAL ERROR TEST CANNOT BE SATISFIED
C                       BECAUSE YOU SPECIFIED A ZERO COMPONENT IN ATOL
C                       AND THE CORRESPONDING COMPUTED SOLUTION
C                       COMPONENT IS ZERO. THUS, A PURE RELATIVE ERROR
C                       TEST IS IMPOSSIBLE FOR THIS COMPONENT.
C
C             IDID = -4,-5  -- NOT APPLICABLE FOR THIS CODE BUT USED
C                       BY OTHER MEMBERS OF DEPAC.
C
C             IDID = -6 -- DDEBDF HAD REPEATED CONVERGENCE TEST FAILURES
C                       ON THE LAST ATTEMPTED STEP.
C
C             IDID = -7 -- DDEBDF HAD REPEATED ERROR TEST FAILURES ON
C                       THE LAST ATTEMPTED STEP.
C
C             IDID = -8,..,-32  -- NOT APPLICABLE FOR THIS CODE BUT
C                       USED BY OTHER MEMBERS OF DEPAC OR POSSIBLE
C                       FUTURE EXTENSIONS.
C
C                         *** TASK TERMINATED ***
C                   REPORTED BY THE VALUE OF IDID=-33
C
C             IDID = -33 -- THE CODE HAS ENCOUNTERED TROUBLE FROM WHICH
C                       IT CANNOT RECOVER. A MESSAGE IS PRINTED
C                       EXPLAINING THE TROUBLE AND CONTROL IS RETURNED
C                       TO THE CALLING PROGRAM. FOR EXAMPLE, THIS OCCURS
C                       WHEN INVALID INPUT IS DETECTED.
C
C      RTOL, ATOL -- THESE QUANTITIES REMAIN UNCHANGED EXCEPT WHEN
C             IDID = -2. IN THIS CASE, THE ERROR TOLERANCES HAVE BEEN
C             INCREASED BY THE CODE TO VALUES WHICH ARE ESTIMATED TO BE
C             APPROPRIATE FOR CONTINUING THE INTEGRATION. HOWEVER, THE
C             REPORTED SOLUTION AT T WAS OBTAINED USING THE INPUT VALUES
C             OF RTOL AND ATOL.
C
C      RWORK, IWORK -- CONTAIN INFORMATION WHICH IS USUALLY OF NO
C             INTEREST TO THE USER BUT NECESSARY FOR SUBSEQUENT CALLS.
C             HOWEVER, YOU MAY FIND USE FOR
C
C             RWORK(11)--WHICH CONTAINS THE STEP SIZE H TO BE
C                        ATTEMPTED ON THE NEXT STEP.
C
C             RWORK(12)--IF THE TOLERANCES HAVE BEEN INCREASED BY THE
C                        CODE (IDID = -2) , THEY WERE MULTIPLIED BY THE
C                        VALUE IN RWORK(12).
C
C             RWORK(13)--WHICH CONTAINS THE CURRENT VALUE OF THE
C                        INDEPENDENT VARIABLE, I.E. THE FARTHEST POINT
C                        INTEGRATION HAS REACHED. THIS WILL BE DIFFERENT
C                        FROM T ONLY WHEN INTERPOLATION HAS BEEN
C                        PERFORMED (IDID=3).
C
C             RWORK(20+I)--WHICH CONTAINS THE APPROXIMATE DERIVATIVE
C                        OF THE SOLUTION COMPONENT Y(I). IN DDEBDF, IT
C                        IS NEVER OBTAINED BY CALLING SUBROUTINE DF TO
C                        EVALUATE THE DIFFERENTIAL EQUATION USING T AND
C                        Y(*), EXCEPT AT THE INITIAL POINT OF
C                        INTEGRATION.
C
C **********************************************************************
C** INPUT -- WHAT TO DO TO CONTINUE THE INTEGRATION **
C**             (CALLS AFTER THE FIRST)             **
C **********************************************************************
C
C        THIS CODE IS ORGANIZED SO THAT SUBSEQUENT CALLS TO CONTINUE THE
C        INTEGRATION INVOLVE LITTLE (IF ANY) ADDITIONAL EFFORT ON YOUR
C        PART. YOU MUST MONITOR THE IDID PARAMETER IN ORDER TO DETERMINE
C        WHAT TO DO NEXT.
C
C        RECALLING THAT THE PRINCIPAL TASK OF THE CODE IS TO INTEGRATE
C        FROM T TO TOUT (THE INTERVAL MODE), USUALLY ALL YOU WILL NEED
C        TO DO IS SPECIFY A NEW TOUT UPON REACHING THE CURRENT TOUT.
C
C        DO NOT ALTER ANY QUANTITY NOT SPECIFICALLY PERMITTED BELOW,
C        IN PARTICULAR DO NOT ALTER NEQ, T, Y(*), RWORK(*), IWORK(*) OR
C        THE DIFFERENTIAL EQUATION IN SUBROUTINE DF. ANY SUCH ALTERATION
C        CONSTITUTES A NEW PROBLEM AND MUST BE TREATED AS SUCH, I.E.
C        YOU MUST START AFRESH.
C
C        YOU CANNOT CHANGE FROM VECTOR TO SCALAR ERROR CONTROL OR VICE
C        VERSA (INFO(2)) BUT YOU CAN CHANGE THE SIZE OF THE ENTRIES OF
C        RTOL, ATOL. INCREASING A TOLERANCE MAKES THE EQUATION EASIER
C        TO INTEGRATE. DECREASING A TOLERANCE WILL MAKE THE EQUATION
C        HARDER TO INTEGRATE AND SHOULD GENERALLY BE AVOIDED.
C
C        YOU CAN SWITCH FROM THE INTERMEDIATE-OUTPUT MODE TO THE
C        INTERVAL MODE (INFO(3)) OR VICE VERSA AT ANY TIME.
C
C        IF IT HAS BEEN NECESSARY TO PREVENT THE INTEGRATION FROM GOING
C        PAST A POINT TSTOP (INFO(4), RWORK(1)), KEEP IN MIND THAT THE
C        CODE WILL NOT INTEGRATE TO ANY TOUT BEYOND THE CURRENTLY
C        SPECIFIED TSTOP. ONCE TSTOP HAS BEEN REACHED YOU MUST CHANGE
C        THE VALUE OF TSTOP OR SET INFO(4)=0. YOU MAY CHANGE INFO(4)
C        OR TSTOP AT ANY TIME BUT YOU MUST SUPPLY THE VALUE OF TSTOP IN
C        RWORK(1) WHENEVER YOU SET INFO(4)=1.
C
C        DO NOT CHANGE INFO(5), INFO(6), IWORK(1), OR IWORK(2)
C        UNLESS YOU ARE GOING TO RESTART THE CODE.
C
C        THE PARAMETER INFO(1) IS USED BY THE CODE TO INDICATE THE
C        BEGINNING OF A NEW PROBLEM AND TO INDICATE WHETHER INTEGRATION
C        IS TO BE CONTINUED. YOU MUST INPUT THE VALUE  INFO(1) = 0
C        WHEN STARTING A NEW PROBLEM. YOU MUST INPUT THE VALUE
C        INFO(1) = 1  IF YOU WISH TO CONTINUE AFTER AN INTERRUPTED TASK.
C        DO NOT SET  INFO(1) = 0  ON A CONTINUATION CALL UNLESS YOU
C        WANT THE CODE TO RESTART AT THE CURRENT T.
C
C                         *** FOLLOWING A COMPLETED TASK ***
C         IF
C             IDID = 1, CALL THE CODE AGAIN TO CONTINUE THE INTEGRATION
C                     ANOTHER STEP IN THE DIRECTION OF TOUT.
C
C             IDID = 2 OR 3, DEFINE A NEW TOUT AND CALL THE CODE AGAIN.
C                     TOUT MUST BE DIFFERENT FROM T. YOU CANNOT CHANGE
C                     THE DIRECTION OF INTEGRATION WITHOUT RESTARTING.
C
C                         *** FOLLOWING AN INTERRUPTED TASK ***
C                     TO SHOW THE CODE THAT YOU REALIZE THE TASK WAS
C                     INTERRUPTED AND THAT YOU WANT TO CONTINUE, YOU
C                     MUST TAKE APPROPRIATE ACTION AND RESET INFO(1) = 1
C         IF
C             IDID = -1, THE CODE HAS ATTEMPTED 5000 STEPS.
C                     IF YOU WANT TO CONTINUE, SET INFO(1) = 1 AND
C                     CALL THE CODE AGAIN. AN ADDITIONAL 5000 STEPS
C                     WILL BE ALLOWED.
C
C             IDID = -2, THE ERROR TOLERANCES RTOL, ATOL HAVE BEEN
C                     INCREASED TO VALUES THE CODE ESTIMATES APPROPRIATE
C                     FOR CONTINUING. YOU MAY WANT TO CHANGE THEM
C                     YOURSELF. IF YOU ARE SURE YOU WANT TO CONTINUE
C                     WITH RELAXED ERROR TOLERANCES, SET INFO(1)=1 AND
C                     CALL THE CODE AGAIN.
C
C             IDID = -3, A SOLUTION COMPONENT IS ZERO AND YOU SET THE
C                     CORRESPONDING COMPONENT OF ATOL TO ZERO. IF YOU
C                     ARE SURE YOU WANT TO CONTINUE, YOU MUST FIRST
C                     ALTER THE ERROR CRITERION TO USE POSITIVE VALUES
C                     FOR THOSE COMPONENTS OF ATOL CORRESPONDING TO ZERO
C                     SOLUTION COMPONENTS, THEN SET INFO(1)=1 AND CALL
C                     THE CODE AGAIN.
C
C             IDID = -4,-5  --- CANNOT OCCUR WITH THIS CODE BUT USED
C                     BY OTHER MEMBERS OF DEPAC.
C
C***REFERENCES
C   SHAMPINE L.F., WATTS H.A., *DEPAC - DESIGN OF A USER ORIENTED
C   PACKAGE OF ODE SOLVERS*, SAND79-2374, SANDIA LABORATORIES, 1979.
C***ROUTINES CALLED  DLSOD,XERRWV
C***COMMON BLOCKS    DEBDF1
C***END PROLOGUE  DDEBDF
      INTEGER IACOR, IBAND, IBEGIN, ICOMI, ICOMR, IDELSN, IDID, IER,
     *      IEWT, IINOUT, IINTEG, IJAC, ILRW, INFLOP, INFO, INIT,
     *      IOWNS, IPAR, IQUIT, ISAVF, ITOL, ITSTAR, ITSTOP, IWM,
     *      IWORK, IYH, IYPOUT, JSTART, KFLAG, KSTEPS, L, LIW, LRW,
     *      MAXORD, METH, MITER, ML, MU, N, NEQ, NFE, NJE, NQ, NQU,
     *      NST
      REAL RTEMP
      DOUBLE PRECISION ATOL, EL0, H, HMIN, HMXI, HU, ROWNS, RPAR,
     *      RTOL, RWORK, T, TN, TOLD, TOUT, UROUND, Y
      LOGICAL INTOUT
C
      DIMENSION Y(NEQ),INFO(15),RTOL(1),ATOL(1),RWORK(LRW),IWORK(LIW),
     *          RPAR(1),IPAR(1)
C
C
      COMMON /DEBDF1/ TOLD,ROWNS(210),EL0,H,HMIN,HMXI,HU,TN,UROUND,
     *                IQUIT,INIT,IYH,IEWT,IACOR,ISAVF,IWM,KSTEPS,IBEGIN,
     *                ITOL,IINTEG,ITSTOP,IJAC,IBAND,IOWNS(6),IER,JSTART,
     *                KFLAG,L,METH,MITER,MAXORD,N,NQ,NST,NFE,NJE,NQU
C
      EXTERNAL DF,DJAC
C
C     ..................................................................
C
C       INITIALIZE A COUNTER FOR MONITORING AN INFINITE LOOP PITFALL
C
      DATA INFLOP /0/
C
C     ..................................................................
C
C          CHECK FOR AN APPARENT INFINITE LOOP
C
C***FIRST EXECUTABLE STATEMENT  DDEBDF
      IF (INFLOP .LT. 5) GO TO 10
      IF (T .NE. RWORK(21+NEQ)) GO TO 10
         RTEMP = T
         WRITE (6,1000) RTEMP,INFO(1)
 1000 FORMAT('DDEBDF - AN APPARENT INFINITE LOOP HAS BEEN DETECTED.'/,
     *'YOU HAVE MADE REPEATED CALLS AT  T = ',1PG12.4,
     *'AND INTEGRATION HAS'/,
     *'NOT ADVANCED. CHECK THE WAY YOU HAVE SET PARAMETERS FOR'/,
     *'THE CALL TO THE CODE, PARTICULARLY INFO(1) ',I3)
      GO TO 130
   10 CONTINUE
C        BEGIN BLOCK PERMITTING ...EXITS TO 80
C
            IDID = 0
C
C           CHECK VALIDITY OF INFO PARAMETERS
C
            IF (INFO(1) .EQ. 0 .OR. INFO(1) .EQ. 1) GO TO 20
            WRITE (6,1100) INFO(1)
 1100 FORMAT('DDEBDF - INFO(1) MUST BE SET TO 0 FOR THE START OF A'/,
     *'NEW PROBLEM, AND MUST BE SET TO 1 FOLLOWING AN INTERRUPTED'/,
     *'TASK.  YOU ARE ATTEMPTING TO CONTINUE THE INTEGRATION '/,
     *'ILLEGALLY BY CALLING THE CODE WITH INFO(1) = ',I3)
               IDID = -33
   20       CONTINUE
C
            IF (INFO(2) .EQ. 0 .OR. INFO(2) .EQ. 1) GO TO 30
               WRITE (6,1200) INFO(2)
 1200 FORMAT('DDEBDF - INFO(2) MUST BE 0 OR 1 INDICATING SCALAR AND'/,
     *'VECTOR ERROR TOLERANCES, RESPECTIVELY.  YOU HAVE CALLED THE'/,
     *'CODE WITH INFO(2) = ',I3)
               IDID = -33
   30       CONTINUE
C
            IF (INFO(3) .EQ. 0 .OR. INFO(3) .EQ. 1) GO TO 40
               WRITE (6,1300) INFO(3)
 1300 FORMAT('DDEBDF - INFO(3) MUST BE 0 OR 1 INDICATING THE INTERVAL'/,
     *'OR INTERMEDIATE-OUTPUT MODE OF INTEGRATION, RESPECTIVELY.'/,
     *'YOU HAVE CALLED THE CODE WITH  INFO(3) = ',I3)
               IDID = -33
   40       CONTINUE
C
            IF (INFO(4) .EQ. 0 .OR. INFO(4) .EQ. 1) GO TO 50
               WRITE (6,1400) INFO(4)
 1400 FORMAT('DDEBDF - INFO(4) MUST BE 0 OR 1 INDICATING WHETHER OR'/,
     *'NOT THE INTEGRATION INTERVAL IS TO BE RESTRICTED BY A POINT'/,
     *'TSTOP.  YOU HAVE CALLED THE CODE WITH  INFO(4) = ',I3)
               IDID = -33
   50       CONTINUE
C
            IF (INFO(5) .EQ. 0 .OR. INFO(5) .EQ. 1) GO TO 60
               WRITE (6,1600) INFO(5)
 1600 FORMAT('DDEBDF - INFO(5) MUST BE 0 OR 1 INDICATING WHETHER THE'/,
     *'CODE IS TOLD TO  FORM THE JACOBIAN MATRIX BY NUMERICAL'/,
     *'DIFFERENCING OR YOU PROVIDE A SUBROUTINE TO EVALUATE IT'/,
     *'ANALYTICALLY.  YOU HAVE  CALLED THE CODE WITH INFO(5) = ',I3)
               IDID = -33
   60       CONTINUE
C
            IF (INFO(6) .EQ. 0 .OR. INFO(6) .EQ. 1) GO TO 70
            WRITE (6,1700) INFO(6)
 1700 FORMAT('DDEBDF - INFO(6) MUST BE 0 OR 1 INDICATING WHETHER THE'/,
     *'CODE IS TOLD TO TREAT THE JACOBIAN AS A FULL (DENSE) MATRIX'/,
     *'OR AS HAVING A SPECIAL BANDED STRUCTURE.  YOU HAVE'/,
     *'CALLED THE CODE WITH INFO(6) = ',I3)
               IDID = -33
   70       CONTINUE
C
            ILRW = NEQ
C        ...EXIT
            IF (INFO(6) .EQ. 0) GO TO 80
C
C           CHECK BANDWIDTH PARAMETERS
C
            ML = IWORK(1)
            MU = IWORK(2)
            ILRW = 2*ML + MU + 1
C        ...EXIT
            IF (ML .GE. 0 .AND. ML .LT. NEQ .AND. MU .GE. 0
     *          .AND. MU .LT. NEQ) GO TO 80
            WRITE (6,1800) ML,MU
 1800 FORMAT('DDEBDF - YOU HAVE TOLD THE CODE (INFO(6) = 1) THAT THE'/,
     *'JACOBIAN MATRIX HAS A SPECIAL BANDED STRUCTURE.  HOWEVER, THE'/,
     *'LOWER (UPPER) BANDWIDTHS  ML (MU) VIOLATE THE CONSTRAINTS'/,
     *'ML,MU .GE. 0  AND  ML,MU .LT. NEQ.  YOU HAVE CALLED THE CODE'/,
     *'WITH ML = ',I3,' AND  MU = ',I3)
            IDID = -33
   80    CONTINUE
C
C        CHECK LRW AND LIW FOR SUFFICIENT STORAGE ALLOCATION
C
         IF (LRW .GE. 250 + (10 + ILRW)*NEQ) GO TO 110
C
            IF (INFO(6) .EQ. 1) GO TO 90
               WRITE (6,1900) LRW
 1900 FORMAT('DDEBDF - LENGTH OF RWORK ARRAY MUST BE AT LEAST'/,
     *'250 + 10*NEQ + NEQ*NEQ YOU HAVE CALLED THE CODE WITH  LRW = ',
     *I5)
               IDID = -33
            GO TO 100
   90       CONTINUE
C
               WRITE (6,2000) LRW
 2000 FORMAT('DDEBDF - LENGTH OF RWORK ARRAY MUST BE AT LEAST'/,
     *'250 + 10*NEQ + (2*ML+MU+1)*NEQ. YOU HAVE CALLED THE CODE'/,
     *'WITH  LRW = ',I5)
               IDID = -33
  100       CONTINUE
  110    CONTINUE
C
         IF (LIW .GE. 55 + NEQ) GO TO 120
            WRITE (6,2100) LIW
 2100 FORMAT('DDEBDF - LENGTH OF IWORK ARRAY MUST BE AT LEAST'/,
     *'55 + NEQ.  YOU HAVE CALLED THE CODE WITH  LIW = ',I5)
            IDID = -33
  120    CONTINUE
C
C        COMPUTE THE INDICES FOR THE ARRAYS TO BE STORED IN THE WORK
C        ARRAY AND RESTORE COMMON BLOCK DATA
C
         ICOMI = 21 + NEQ
         IINOUT = ICOMI + 33
C
         IYPOUT = 21
         ITSTAR = 21 + NEQ
         ICOMR = 22 + NEQ
C
         IF (INFO(1) .NE. 0) INTOUT = IWORK(IINOUT) .NE. (-1)
C        CALL DRSCO(RWORK(ICOMR),IWORK(ICOMI))
C
         IYH = ICOMR + 218
         IEWT = IYH + 6*NEQ
         ISAVF = IEWT + NEQ
         IACOR = ISAVF + NEQ
         IWM = IACOR + NEQ
         IDELSN = IWM + 2 + ILRW*NEQ
C
         IBEGIN = INFO(1)
         ITOL = INFO(2)
         IINTEG = INFO(3)
         ITSTOP = INFO(4)
         IJAC = INFO(5)
         IBAND = INFO(6)
         RWORK(ITSTAR) = T
C
         CALL DLSOD(DF,NEQ,T,Y,TOUT,RTOL,ATOL,IDID,RWORK(IYPOUT),
     *              RWORK(IYH),RWORK(IYH),RWORK(IEWT),RWORK(ISAVF),
     *              RWORK(IACOR),RWORK(IWM),IWORK(1),DJAC,INTOUT,
     *              RWORK(1),RWORK(12),RWORK(IDELSN),RPAR,IPAR)
C
         IWORK(IINOUT) = -1
         IF (INTOUT) IWORK(IINOUT) = 1
C
         IF (IDID .NE. (-2)) INFLOP = INFLOP + 1
         IF (T .NE. RWORK(ITSTAR)) INFLOP = 0
C        CALL DSVCO(RWORK(ICOMR),IWORK(ICOMI))
         RWORK(11) = H
         RWORK(13) = TN
         INFO(1) = IBEGIN
  130 CONTINUE
C
      RETURN
      END
      DOUBLE PRECISION FUNCTION DDOT(N,DX,INCX,DY,INCY)
C***BEGIN PROLOGUE  DDOT
C***DATE WRITTEN   791001   (YYMMDD)
C***REVISION DATE  820801   (YYMMDD)
C***CATEGORY NO.  D1A4
C***KEYWORDS  BLAS,LINEAR ALGEBRA,VECTOR,INNER PRODUCT,DOUBLE PRECISION
C***AUTHOR  LAWSON, C. L., (JPL)
C           HANSON, R. J., (SNLA)
C           KINCAID, D. R., (U. OF TEXAS)
C           KROGH, F. T., (JPL)
C***PURPOSE  D.P. INNER PRODUCT OF D.P. VECTORS
C***DESCRIPTION
C                B L A S  SUBPROGRAM
C    DESCRIPTION OF PARAMETERS
C
C     --INPUT--
C        N  NUMBER OF ELEMENTS IN INPUT VECTOR(S)
C       DX  DOUBLE PRECISION VECTOR WITH N ELEMENTS
C     INCX  STORAGE SPACING BETWEEN ELEMENTS OF DX
C       DY  DOUBLE PRECISION VECTOR WITH N ELEMENTS
C     INCY  STORAGE SPACING BETWEEN ELEMENTS OF DY
C
C     --OUTPUT--
C     DDOT  DOUBLE PRECISION DOT PRODUCT (ZERO IF N .LE. 0)
C
C     RETURNS THE DOT PRODUCT OF DOUBLE PRECISION DX AND DY.
C     DDOT = SUM FOR I = 0 TO N-1 OF  DX(LX+I*INCX) * DY(LY+I*INCY)
C     WHERE LX = 1 IF INCX .GE. 0, ELSE LX = (-INCX)*N, AND LY IS
C     DEFINED IN A SIMILAR WAY USING INCY.
C***REFERENCES  LAWSON C.L., HANSON R.J., KINCAID D.R., KROGH F.T.,
C                 *BASIC LINEAR ALGEBRA SUBPROGRAMS FOR FORTRAN USAGE*,
C                 ALGORITHM NO. 539, TRANSACTIONS ON MATHEMATICAL
C                 SOFTWARE, VOLUME 5, NUMBER 3, SEPTEMBER 1979, 308-323
C***ROUTINES CALLED  (NONE)
C***END PROLOGUE  DDOT
C
      DOUBLE PRECISION DX(1),DY(1)
C***FIRST EXECUTABLE STATEMENT  DDOT
      DDOT = 0.D0
      IF(N.LE.0)RETURN
      IF(INCX.EQ.INCY) IF(INCX-1) 5,20,60
    5 CONTINUE
C
C         CODE FOR UNEQUAL OR NONPOSITIVE INCREMENTS.
C
      IX = 1
      IY = 1
      IF(INCX.LT.0)IX = (-N+1)*INCX + 1
      IF(INCY.LT.0)IY = (-N+1)*INCY + 1
      DO 10 I = 1,N
         DDOT = DDOT + DX(IX)*DY(IY)
        IX = IX + INCX
        IY = IY + INCY
   10 CONTINUE
      RETURN
C
C        CODE FOR BOTH INCREMENTS EQUAL TO 1.
C
C
C        CLEAN-UP LOOP SO REMAINING VECTOR LENGTH IS A MULTIPLE OF 5.
C
   20 M = MOD(N,5)
      IF( M .EQ. 0 ) GO TO 40
      DO 30 I = 1,M
         DDOT = DDOT + DX(I)*DY(I)
   30 CONTINUE
      IF( N .LT. 5 ) RETURN
   40 MP1 = M + 1
      DO 50 I = MP1,N,5
         DDOT = DDOT + DX(I)*DY(I) + DX(I+1)*DY(I+1) +
     $   DX(I + 2)*DY(I + 2) + DX(I + 3)*DY(I + 3) + DX(I + 4)*DY(I + 4)
   50 CONTINUE
      RETURN
C
C         CODE FOR POSITIVE EQUAL INCREMENTS .NE.1.
C
   60 CONTINUE
      NS = N*INCX
          DO 70 I=1,NS,INCX
          DDOT = DDOT + DX(I)*DY(I)
   70     CONTINUE
      RETURN
      END
      SUBROUTINE DGBFA(ABD,LDA,N,ML,MU,IPVT,INFO)
C***BEGIN PROLOGUE  DGBFA
C***DATE WRITTEN   780814   (YYMMDD)
C***REVISION DATE  820801   (YYMMDD)
C***CATEGORY NO.  D2A2
C***KEYWORDS  LINPACK,LINEAR ALGEBRA,MATRIX,FACTOR,BANDED,
C             DOUBLE PRECISION
C***AUTHOR  MOLER, C. B., (U. OF NEW MEXICO)
C***PURPOSE  FACTORS A DOUBLE PRECISION BAND MATRIX BY ELIMINATION.
C***DESCRIPTION
C     DGBFA FACTORS A DOUBLE PRECISION BAND MATRIX BY ELIMINATION.
C
C     DGBFA IS USUALLY CALLED BY DGBCO, BUT IT CAN BE CALLED
C     DIRECTLY WITH A SAVING IN TIME IF  RCOND  IS NOT NEEDED.
C
C     ON ENTRY
C
C        ABD     DOUBLE PRECISION(LDA, N)
C                CONTAINS THE MATRIX IN BAND STORAGE.  THE COLUMNS
C                OF THE MATRIX ARE STORED IN THE COLUMNS OF  ABD  AND
C                THE DIAGONALS OF THE MATRIX ARE STORED IN ROWS
C                ML+1 THROUGH 2*ML+MU+1 OF  ABD .
C                SEE THE COMMENTS BELOW FOR DETAILS.
C
C        LDA     INTEGER
C                THE LEADING DIMENSION OF THE ARRAY  ABD .
C                LDA MUST BE .GE. 2*ML + MU + 1 .
C
C        N       INTEGER
C                THE ORDER OF THE ORIGINAL MATRIX.
C
C        ML      INTEGER
C                NUMBER OF DIAGONALS BELOW THE MAIN DIAGONAL.
C                0 .LE. ML .LT.  N .
C
C        MU      INTEGER
C                NUMBER OF DIAGONALS ABOVE THE MAIN DIAGONAL.
C                0 .LE. MU .LT.  N .
C                MORE EFFICIENT IF  ML .LE. MU .
C     ON RETURN
C
C        ABD     AN UPPER TRIANGULAR MATRIX IN BAND STORAGE AND
C                THE MULTIPLIERS WHICH WERE USED TO OBTAIN IT.
C                THE FACTORIZATION CAN BE WRITTEN  A = L*U  WHERE
C                L  IS A PRODUCT OF PERMUTATION AND UNIT LOWER
C                TRIANGULAR MATRICES AND  U  IS UPPER TRIANGULAR.
C
C        IPVT    INTEGER(N)
C                AN INTEGER VECTOR OF PIVOT INDICES.
C
C        INFO    INTEGER
C                = 0  NORMAL VALUE.
C                = K  IF  U(K,K) .EQ. 0.0 .  THIS IS NOT AN ERROR
C                     CONDITION FOR THIS SUBROUTINE, BUT IT DOES
C                     INDICATE THAT DGBSL WILL DIVIDE BY ZERO IF
C                     CALLED.  USE  RCOND  IN DGBCO FOR A RELIABLE
C                     INDICATION OF SINGULARITY.
C
C     BAND STORAGE
C
C           IF  A  IS A BAND MATRIX, THE FOLLOWING PROGRAM SEGMENT
C           WILL SET UP THE INPUT.
C
C                   ML = (BAND WIDTH BELOW THE DIAGONAL)
C                   MU = (BAND WIDTH ABOVE THE DIAGONAL)
C                   M = ML + MU + 1
C                   DO 20 J = 1, N
C                      I1 = MAX0(1, J-MU)
C                      I2 = MIN0(N, J+ML)
C                      DO 10 I = I1, I2
C                         K = I - J + M
C                         ABD(K,J) = A(I,J)
C                10    CONTINUE
C                20 CONTINUE
C
C           THIS USES ROWS  ML+1  THROUGH  2*ML+MU+1  OF  ABD .
C           IN ADDITION, THE FIRST  ML  ROWS IN  ABD  ARE USED FOR
C           ELEMENTS GENERATED DURING THE TRIANGULARIZATION.
C           THE TOTAL NUMBER OF ROWS NEEDED IN  ABD  IS  2*ML+MU+1 .
C           THE  ML+MU BY ML+MU  UPPER LEFT TRIANGLE AND THE
C           ML BY ML  LOWER RIGHT TRIANGLE ARE NOT REFERENCED.
C
C     LINPACK.  THIS VERSION DATED 08/14/78 .
C     CLEVE MOLER, UNIVERSITY OF NEW MEXICO, ARGONNE NATIONAL LAB.
C
C     SUBROUTINES AND FUNCTIONS
C
C     BLAS DAXPY,DSCAL,IDAMAX
C     FORTRAN MAX0,MIN0
C***REFERENCES  DONGARRA J.J., BUNCH J.R., MOLER C.B., STEWART G.W.,
C                 *LINPACK USERS  GUIDE*, SIAM, 1979.
C***ROUTINES CALLED  DAXPY,DSCAL,IDAMAX
C***END PROLOGUE  DGBFA
      INTEGER LDA,N,ML,MU,IPVT(1),INFO
      DOUBLE PRECISION ABD(LDA,1)
C
      DOUBLE PRECISION T
      INTEGER I,IDAMAX,I0,J,JU,JZ,J0,J1,K,KP1,L,LM,M,MM,NM1
C***FIRST EXECUTABLE STATEMENT  DGBFA
C
      M = ML + MU + 1
      INFO = 0
C
C     ZERO INITIAL FILL-IN COLUMNS
C
      J0 = MU + 2
      J1 = MIN0(N,M) - 1
      IF (J1 .LT. J0) GO TO 30
      DO 20 JZ = J0, J1
         I0 = M + 1 - JZ
         DO 10 I = I0, ML
            ABD(I,JZ) = 0.0D0
   10    CONTINUE
   20 CONTINUE
   30 CONTINUE
      JZ = J1
      JU = 0
C
C     GAUSSIAN ELIMINATION WITH PARTIAL PIVOTING
C
      NM1 = N - 1
      IF (NM1 .LT. 1) GO TO 130
      DO 120 K = 1, NM1
         KP1 = K + 1
C
C        ZERO NEXT FILL-IN COLUMN
C
         JZ = JZ + 1
         IF (JZ .GT. N) GO TO 50
         IF (ML .LT. 1) GO TO 50
            DO 40 I = 1, ML
               ABD(I,JZ) = 0.0D0
   40       CONTINUE
   50    CONTINUE
C
C        FIND L = PIVOT INDEX
C
         LM = MIN0(ML,N-K)
         L = IDAMAX(LM+1,ABD(M,K),1) + M - 1
         IPVT(K) = L + K - M
C
C        ZERO PIVOT IMPLIES THIS COLUMN ALREADY TRIANGULARIZED
C
         IF (ABD(L,K) .EQ. 0.0D0) GO TO 100
C
C           INTERCHANGE IF NECESSARY
C
            IF (L .EQ. M) GO TO 60
               T = ABD(L,K)
               ABD(L,K) = ABD(M,K)
               ABD(M,K) = T
   60       CONTINUE
C
C           COMPUTE MULTIPLIERS
C
            T = -1.0D0/ABD(M,K)
            CALL DSCAL(LM,T,ABD(M+1,K),1)
C
C           ROW ELIMINATION WITH COLUMN INDEXING
C
            JU = MIN0(MAX0(JU,MU+IPVT(K)),N)
            MM = M
            IF (JU .LT. KP1) GO TO 90
            DO 80 J = KP1, JU
               L = L - 1
               MM = MM - 1
               T = ABD(L,J)
               IF (L .EQ. MM) GO TO 70
                  ABD(L,J) = ABD(MM,J)
                  ABD(MM,J) = T
   70          CONTINUE
               CALL DAXPY(LM,T,ABD(M+1,K),1,ABD(MM+1,J),1)
   80       CONTINUE
   90       CONTINUE
         GO TO 110
  100    CONTINUE
            INFO = K
  110    CONTINUE
  120 CONTINUE
  130 CONTINUE
      IPVT(N) = N
      IF (ABD(M,N) .EQ. 0.0D0) INFO = N
      RETURN
      END
      SUBROUTINE DGBSL(ABD,LDA,N,ML,MU,IPVT,B,JOB)
C***BEGIN PROLOGUE  DGBSL
C***DATE WRITTEN   780814   (YYMMDD)
C***REVISION DATE  820801   (YYMMDD)
C***CATEGORY NO.  D2A2
C***KEYWORDS  LINPACK,LINEAR ALGEBRA,MATRIX,SOLVE,BANDED,
C             DOUBLE PRECISION
C***AUTHOR  MOLER, C. B., (U. OF NEW MEXICO)
C***PURPOSE  SOLVES THE DOUBLE PRECISION BAND SYSTEM  A*X=B OR
C            TRANS(A)*X=B USING THE FACTORS COMPUTED BY DGBCO OR DGBFA.
C***DESCRIPTION
C     DGBSL SOLVES THE DOUBLE PRECISION BAND SYSTEM
C     A * X = B  OR  TRANS(A) * X = B
C     USING THE FACTORS COMPUTED BY DGBCO OR DGBFA.
C
C     ON ENTRY
C
C        ABD     DOUBLE PRECISION(LDA, N)
C                THE OUTPUT FROM DGBCO OR DGBFA.
C
C        LDA     INTEGER
C                THE LEADING DIMENSION OF THE ARRAY  ABD .
C
C        N       INTEGER
C                THE ORDER OF THE ORIGINAL MATRIX.
C
C        ML      INTEGER
C                NUMBER OF DIAGONALS BELOW THE MAIN DIAGONAL.
C
C        MU      INTEGER
C                NUMBER OF DIAGONALS ABOVE THE MAIN DIAGONAL.
C
C        IPVT    INTEGER(N)
C                THE PIVOT VECTOR FROM DGBCO OR DGBFA.
C
C        B       DOUBLE PRECISION(N)
C                THE RIGHT HAND SIDE VECTOR.
C
C        JOB     INTEGER
C                = 0         TO SOLVE  A*X = B ,
C                = NONZERO   TO SOLVE  TRANS(A)*X = B , WHERE
C                            TRANS(A)  IS THE TRANSPOSE.
C
C     ON RETURN
C
C        B       THE SOLUTION VECTOR  X .
C
C     ERROR CONDITION
C
C        A DIVISION BY ZERO WILL OCCUR IF THE INPUT FACTOR CONTAINS A
C        ZERO ON THE DIAGONAL.  TECHNICALLY THIS INDICATES SINGULARITY
C        BUT IT IS OFTEN CAUSED BY IMPROPER ARGUMENTS OR IMPROPER
C        SETTING OF LDA .  IT WILL NOT OCCUR IF THE SUBROUTINES ARE
C        CALLED CORRECTLY AND IF DGBCO HAS SET RCOND .GT. 0.0
C        OR DGBFA HAS SET INFO .EQ. 0 .
C
C     TO COMPUTE  INVERSE(A) * C  WHERE  C  IS A MATRIX
C     WITH  P  COLUMNS
C           CALL DGBCO(ABD,LDA,N,ML,MU,IPVT,RCOND,Z)
C           IF (RCOND IS TOO SMALL) GO TO ...
C           DO 10 J = 1, P
C              CALL DGBSL(ABD,LDA,N,ML,MU,IPVT,C(1,J),0)
C        10 CONTINUE
C
C     LINPACK.  THIS VERSION DATED 08/14/78 .
C     CLEVE MOLER, UNIVERSITY OF NEW MEXICO, ARGONNE NATIONAL LAB.
C
C     SUBROUTINES AND FUNCTIONS
C
C     BLAS DAXPY,DDOT
C     FORTRAN MIN0
C***REFERENCES  DONGARRA J.J., BUNCH J.R., MOLER C.B., STEWART G.W.,
C                 *LINPACK USERS  GUIDE*, SIAM, 1979.
C***ROUTINES CALLED  DAXPY,DDOT
C***END PROLOGUE  DGBSL
      INTEGER LDA,N,ML,MU,IPVT(1),JOB
      DOUBLE PRECISION ABD(LDA,1),B(1)
C
      DOUBLE PRECISION DDOT,T
      INTEGER K,KB,L,LA,LB,LM,M,NM1
C***FIRST EXECUTABLE STATEMENT  DGBSL
      M = MU + ML + 1
      NM1 = N - 1
      IF (JOB .NE. 0) GO TO 50
C
C        JOB = 0 , SOLVE  A * X = B
C        FIRST SOLVE L*Y = B
C
         IF (ML .EQ. 0) GO TO 30
         IF (NM1 .LT. 1) GO TO 30
            DO 20 K = 1, NM1
               LM = MIN0(ML,N-K)
               L = IPVT(K)
               T = B(L)
               IF (L .EQ. K) GO TO 10
                  B(L) = B(K)
                  B(K) = T
   10          CONTINUE
               CALL DAXPY(LM,T,ABD(M+1,K),1,B(K+1),1)
   20       CONTINUE
   30    CONTINUE
C
C        NOW SOLVE  U*X = Y
C
         DO 40 KB = 1, N
            K = N + 1 - KB
            B(K) = B(K)/ABD(M,K)
            LM = MIN0(K,M) - 1
            LA = M - LM
            LB = K - LM
            T = -B(K)
            CALL DAXPY(LM,T,ABD(LA,K),1,B(LB),1)
   40    CONTINUE
      GO TO 100
   50 CONTINUE
C
C        JOB = NONZERO, SOLVE  TRANS(A) * X = B
C        FIRST SOLVE  TRANS(U)*Y = B
C
         DO 60 K = 1, N
            LM = MIN0(K,M) - 1
            LA = M - LM
            LB = K - LM
            T = DDOT(LM,ABD(LA,K),1,B(LB),1)
            B(K) = (B(K) - T)/ABD(M,K)
   60    CONTINUE
C
C        NOW SOLVE TRANS(L)*X = Y
C
         IF (ML .EQ. 0) GO TO 90
         IF (NM1 .LT. 1) GO TO 90
            DO 80 KB = 1, NM1
               K = N - KB
               LM = MIN0(ML,N-K)
               B(K) = B(K) + DDOT(LM,ABD(M+1,K),1,B(K+1),1)
               L = IPVT(K)
               IF (L .EQ. K) GO TO 70
                  T = B(L)
                  B(L) = B(K)
                  B(K) = T
   70          CONTINUE
   80       CONTINUE
   90    CONTINUE
  100 CONTINUE
      RETURN
      END
      SUBROUTINE DGEFA(A,LDA,N,IPVT,INFO)
C***BEGIN PROLOGUE  DGEFA
C***DATE WRITTEN   780814   (YYMMDD)
C***REVISION DATE  820801   (YYMMDD)
C***CATEGORY NO.  D2A1
C***KEYWORDS  LINPACK,LINEAR ALGEBRA,MATRIX,FACTOR,DOUBLE PRECISION
C***AUTHOR  MOLER, C. B., (U. OF NEW MEXICO)
C***PURPOSE  FACTORS A DOUBLE PRECISION MATRIX BY GAUSSIAN ELIMINATION.
C***DESCRIPTION
C     DGEFA FACTORS A DOUBLE PRECISION MATRIX BY GAUSSIAN ELIMINATION.
C
C     DGEFA IS USUALLY CALLED BY DGECO, BUT IT CAN BE CALLED
C     DIRECTLY WITH A SAVING IN TIME IF  RCOND  IS NOT NEEDED.
C     (TIME FOR DGECO) = (1 + 9/N)*(TIME FOR DGEFA) .
C
C     ON ENTRY
C
C        A       DOUBLE PRECISION(LDA, N)
C                THE MATRIX TO BE FACTORED.
C
C        LDA     INTEGER
C                THE LEADING DIMENSION OF THE ARRAY  A .
C
C        N       INTEGER
C                THE ORDER OF THE MATRIX  A .
C
C     ON RETURN
C
C        A       AN UPPER TRIANGULAR MATRIX AND THE MULTIPLIERS
C                WHICH WERE USED TO OBTAIN IT.
C                THE FACTORIZATION CAN BE WRITTEN  A = L*U  WHERE
C                L  IS A PRODUCT OF PERMUTATION AND UNIT LOWER
C                TRIANGULAR MATRICES AND  U  IS UPPER TRIANGULAR.
C
C        IPVT    INTEGER(N)
C                AN INTEGER VECTOR OF PIVOT INDICES.
C
C        INFO    INTEGER
C                = 0  NORMAL VALUE.
C                = K  IF  U(K,K) .EQ. 0.0 .  THIS IS NOT AN ERROR
C                     CONDITION FOR THIS SUBROUTINE, BUT IT DOES
C                     INDICATE THAT DGESL OR DGEDI WILL DIVIDE BY ZERO
C                     IF CALLED.  USE  RCOND  IN DGECO FOR A RELIABLE
C                     INDICATION OF SINGULARITY.
C
C     LINPACK.  THIS VERSION DATED 08/14/78 .
C     CLEVE MOLER, UNIVERSITY OF NEW MEXICO, ARGONNE NATIONAL LAB.
C
C     SUBROUTINES AND FUNCTIONS
C
C     BLAS DAXPY,DSCAL,IDAMAX
C***REFERENCES  DONGARRA J.J., BUNCH J.R., MOLER C.B., STEWART G.W.,
C                 *LINPACK USERS  GUIDE*, SIAM, 1979.
C***ROUTINES CALLED  DAXPY,DSCAL,IDAMAX
C***END PROLOGUE  DGEFA
      INTEGER LDA,N,IPVT(1),INFO
      DOUBLE PRECISION A(LDA,1)
C
      DOUBLE PRECISION T
      INTEGER IDAMAX,J,K,KP1,L,NM1
C***FIRST EXECUTABLE STATEMENT  DGEFA
C
C     GAUSSIAN ELIMINATION WITH PARTIAL PIVOTING
C
      INFO = 0
      NM1 = N - 1
      IF (NM1 .LT. 1) GO TO 70
      DO 60 K = 1, NM1
         KP1 = K + 1
C
C        FIND L = PIVOT INDEX
C
         L = IDAMAX(N-K+1,A(K,K),1) + K - 1
         IPVT(K) = L
C
C        ZERO PIVOT IMPLIES THIS COLUMN ALREADY TRIANGULARIZED
C
         IF (A(L,K) .EQ. 0.0D0) GO TO 40
C
C           INTERCHANGE IF NECESSARY
C
            IF (L .EQ. K) GO TO 10
               T = A(L,K)
               A(L,K) = A(K,K)
               A(K,K) = T
   10       CONTINUE
C
C           COMPUTE MULTIPLIERS
C
            T = -1.0D0/A(K,K)
            CALL DSCAL(N-K,T,A(K+1,K),1)
C
C           ROW ELIMINATION WITH COLUMN INDEXING
C
            DO 30 J = KP1, N
               T = A(L,J)
               IF (L .EQ. K) GO TO 20
                  A(L,J) = A(K,J)
                  A(K,J) = T
   20          CONTINUE
               CALL DAXPY(N-K,T,A(K+1,K),1,A(K+1,J),1)
   30       CONTINUE
         GO TO 50
   40    CONTINUE
            INFO = K
   50    CONTINUE
   60 CONTINUE
   70 CONTINUE
      IPVT(N) = N
      IF (A(N,N) .EQ. 0.0D0) INFO = N
      RETURN
      END
      SUBROUTINE DGESL(A,LDA,N,IPVT,B,JOB)
C***BEGIN PROLOGUE  DGESL
C***DATE WRITTEN   780814   (YYMMDD)
C***REVISION DATE  820801   (YYMMDD)
C***CATEGORY NO.  D2A1
C***KEYWORDS  LINPACK,LINEAR ALGEBRA,MATRIX,SOLVE,DOUBLE PRECISION
C***AUTHOR  MOLER, C. B., (U. OF NEW MEXICO)
C***PURPOSE  SOLVES THE DOUBLE PRECISION SYSTEM  A*X=B OR  TRANS(A)*X=B
C            USING THE FACTORS COMPUTED BY DGECO OR DGEFA.
C***DESCRIPTION
C     DGESL SOLVES THE DOUBLE PRECISION SYSTEM
C     A * X = B  OR  TRANS(A) * X = B
C     USING THE FACTORS COMPUTED BY DGECO OR DGEFA.
C
C     ON ENTRY
C
C        A       DOUBLE PRECISION(LDA, N)
C                THE OUTPUT FROM DGECO OR DGEFA.
C
C        LDA     INTEGER
C                THE LEADING DIMENSION OF THE ARRAY  A .
C
C        N       INTEGER
C                THE ORDER OF THE MATRIX  A .
C
C        IPVT    INTEGER(N)
C                THE PIVOT VECTOR FROM DGECO OR DGEFA.
C
C        B       DOUBLE PRECISION(N)
C                THE RIGHT HAND SIDE VECTOR.
C
C        JOB     INTEGER
C                = 0         TO SOLVE  A*X = B ,
C                = NONZERO   TO SOLVE  TRANS(A)*X = B  WHERE
C                            TRANS(A)  IS THE TRANSPOSE.
C
C     ON RETURN
C
C        B       THE SOLUTION VECTOR  X .
C
C     ERROR CONDITION
C
C        A DIVISION BY ZERO WILL OCCUR IF THE INPUT FACTOR CONTAINS A
C        ZERO ON THE DIAGONAL.  TECHNICALLY THIS INDICATES SINGULARITY
C        BUT IT IS OFTEN CAUSED BY IMPROPER ARGUMENTS OR IMPROPER
C        SETTING OF LDA .  IT WILL NOT OCCUR IF THE SUBROUTINES ARE
C        CALLED CORRECTLY AND IF DGECO HAS SET RCOND .GT. 0.0
C        OR DGEFA HAS SET INFO .EQ. 0 .
C
C     TO COMPUTE  INVERSE(A) * C  WHERE  C  IS A MATRIX
C     WITH  P  COLUMNS
C           CALL DGECO(A,LDA,N,IPVT,RCOND,Z)
C           IF (RCOND IS TOO SMALL) GO TO ...
C           DO 10 J = 1, P
C              CALL DGESL(A,LDA,N,IPVT,C(1,J),0)
C        10 CONTINUE
C
C     LINPACK.  THIS VERSION DATED 08/14/78 .
C     CLEVE MOLER, UNIVERSITY OF NEW MEXICO, ARGONNE NATIONAL LAB.
C
C     SUBROUTINES AND FUNCTIONS
C
C     BLAS DAXPY,DDOT
C***REFERENCES  DONGARRA J.J., BUNCH J.R., MOLER C.B., STEWART G.W.,
C                 *LINPACK USERS  GUIDE*, SIAM, 1979.
C***ROUTINES CALLED  DAXPY,DDOT
C***END PROLOGUE  DGESL
      INTEGER LDA,N,IPVT(1),JOB
      DOUBLE PRECISION A(LDA,1),B(1)
C
      DOUBLE PRECISION DDOT,T
      INTEGER K,KB,L,NM1
C***FIRST EXECUTABLE STATEMENT  DGESL
      NM1 = N - 1
      IF (JOB .NE. 0) GO TO 50
C
C        JOB = 0 , SOLVE  A * X = B
C        FIRST SOLVE  L*Y = B
C
         IF (NM1 .LT. 1) GO TO 30
         DO 20 K = 1, NM1
            L = IPVT(K)
            T = B(L)
            IF (L .EQ. K) GO TO 10
               B(L) = B(K)
               B(K) = T
   10       CONTINUE
            CALL DAXPY(N-K,T,A(K+1,K),1,B(K+1),1)
   20    CONTINUE
   30    CONTINUE
C
C        NOW SOLVE  U*X = Y
C
         DO 40 KB = 1, N
            K = N + 1 - KB
            B(K) = B(K)/A(K,K)
            T = -B(K)
            CALL DAXPY(K-1,T,A(1,K),1,B(1),1)
   40    CONTINUE
      GO TO 100
   50 CONTINUE
C
C        JOB = NONZERO, SOLVE  TRANS(A) * X = B
C        FIRST SOLVE  TRANS(U)*Y = B
C
         DO 60 K = 1, N
            T = DDOT(K-1,A(1,K),1,B(1),1)
            B(K) = (B(K) - T)/A(K,K)
   60    CONTINUE
C
C        NOW SOLVE TRANS(L)*X = Y
C
         IF (NM1 .LT. 1) GO TO 90
         DO 80 KB = 1, NM1
            K = N - KB
            B(K) = B(K) + DDOT(N-K,A(K+1,K),1,B(K+1),1)
            L = IPVT(K)
            IF (L .EQ. K) GO TO 70
               T = B(L)
               B(L) = B(K)
               B(K) = T
   70       CONTINUE
   80    CONTINUE
   90    CONTINUE
  100 CONTINUE
      RETURN
      END
      SUBROUTINE DHSTRT(DF,NEQ,A,B,Y,YPRIME,ETOL,MORDER,SMALL,BIG,SPY,
     *                  PV,YP,SF,RPAR,IPAR,H)
C***BEGIN PROLOGUE  DHSTRT
C***REFER TO  DDERKF,DDEABM,DDEBDF
C   DHSTRT COMPUTES A STARTING STEP SIZE TO BE USED IN SOLVING INITIAL
C   VALUE PROBLEMS IN ORDINARY DIFFERENTIAL EQUATIONS.
C
C **********************************************************************
C  ABSTRACT
C
C     SUBROUTINE DHSTRT COMPUTES A STARTING STEP SIZE TO BE USED BY AN
C     INITIAL VALUE METHOD IN SOLVING ORDINARY DIFFERENTIAL EQUATIONS.
C     IT IS BASED ON AN ESTIMATE OF THE LOCAL LIPSCHITZ CONSTANT FOR THE
C     DIFFERENTIAL EQUATION   (LOWER BOUND ON A NORM OF THE JACOBIAN) ,
C     A BOUND ON THE DIFFERENTIAL EQUATION  (FIRST DERIVATIVE) , AND
C     A BOUND ON THE PARTIAL DERIVATIVE OF THE EQUATION WITH RESPECT TO
C     THE INDEPENDENT VARIABLE.
C     (ALL APPROXIMATED NEAR THE INITIAL POINT A)
C
C     SUBROUTINE DHSTRT USES A FUNCTION SUBPROGRAM DVNORM FOR COMPUTING
C     A VECTOR NORM. THE MAXIMUM NORM IS PRESENTLY UTILIZED THOUGH IT
C     CAN EASILY BE REPLACED BY ANY OTHER VECTOR NORM. IT IS PRESUMED
C     THAT ANY REPLACEMENT NORM ROUTINE WOULD BE CAREFULLY CODED TO
C     PREVENT UNNECESSARY UNDERFLOWS OR OVERFLOWS FROM OCCURRING, AND
C     ALSO, WOULD NOT ALTER THE VECTOR OR NUMBER OF COMPONENTS.
C
C **********************************************************************
C  ON INPUT YOU MUST PROVIDE THE FOLLOWING
C
C      DF -- THIS IS A SUBROUTINE OF THE FORM
C                               DF(X,U,UPRIME,RPAR,IPAR)
C             WHICH DEFINES THE SYSTEM OF FIRST ORDER DIFFERENTIAL
C             EQUATIONS TO BE SOLVED. FOR THE GIVEN VALUES OF X AND THE
C             VECTOR  U(*)=(U(1),U(2),...,U(NEQ)) , THE SUBROUTINE MUST
C             EVALUATE THE NEQ COMPONENTS OF THE SYSTEM OF DIFFERENTIAL
C             EQUATIONS  DU/DX=DF(X,U)  AND STORE THE DERIVATIVES IN THE
C             ARRAY UPRIME(*), THAT IS,  UPRIME(I) = * DU(I)/DX *  FOR
C             EQUATIONS I=1,...,NEQ.
C
C             SUBROUTINE DF MUST NOT ALTER X OR U(*). YOU MUST DECLARE
C             THE NAME DF IN AN EXTERNAL STATEMENT IN YOUR PROGRAM THAT
C             CALLS DHSTRT. YOU MUST DIMENSION U AND UPRIME IN DF.
C
C             RPAR AND IPAR ARE DOUBLE PRECISION AND INTEGER PARAMETER
C             ARRAYS WHICH YOU CAN USE FOR COMMUNICATION BETWEEN YOUR
C             PROGRAM AND SUBROUTINE DF. THEY ARE NOT USED OR ALTERED BY
C             DHSTRT. IF YOU DO NOT NEED RPAR OR IPAR, IGNORE THESE
C             PARAMETERS BY TREATING THEM AS DUMMY ARGUMENTS. IF YOU DO
C             CHOOSE TO USE THEM, DIMENSION THEM IN YOUR PROGRAM AND IN
C             DF AS ARRAYS OF APPROPRIATE LENGTH.
C
C      NEQ -- THIS IS THE NUMBER OF (FIRST ORDER) DIFFERENTIAL EQUATIONS
C             TO BE INTEGRATED.
C
C      A -- THIS IS THE INITIAL POINT OF INTEGRATION.
C
C      B -- THIS IS A VALUE OF THE INDEPENDENT VARIABLE USED TO DEFINE
C             THE DIRECTION OF INTEGRATION. A REASONABLE CHOICE IS TO
C             SET  B  TO THE FIRST POINT AT WHICH A SOLUTION IS DESIRED.
C             YOU CAN ALSO USE  B, IF NECESSARY, TO RESTRICT THE LENGTH
C             OF THE FIRST INTEGRATION STEP BECAUSE THE ALGORITHM WILL
C             NOT COMPUTE A STARTING STEP LENGTH WHICH IS BIGGER THAN
C             DABS(B-A), UNLESS  B  HAS BEEN CHOSEN TOO CLOSE TO  A.
C             (IT IS PRESUMED THAT DHSTRT HAS BEEN CALLED WITH  B
C             DIFFERENT FROM  A  ON THE MACHINE BEING USED. ALSO SEE THE
C             DISCUSSION ABOUT THE PARAMETER  SMALL.)
C
C      Y(*) -- THIS IS THE VECTOR OF INITIAL VALUES OF THE NEQ SOLUTION
C             COMPONENTS AT THE INITIAL POINT  A.
C
C      YPRIME(*) -- THIS IS THE VECTOR OF DERIVATIVES OF THE NEQ
C             SOLUTION COMPONENTS AT THE INITIAL POINT  A.
C             (DEFINED BY THE DIFFERENTIAL EQUATIONS IN SUBROUTINE DF)
C
C      ETOL -- THIS IS THE VECTOR OF ERROR TOLERANCES CORRESPONDING TO
C             THE NEQ SOLUTION COMPONENTS. IT IS ASSUMED THAT ALL
C             ELEMENTS ARE POSITIVE. FOLLOWING THE FIRST INTEGRATION
C             STEP, THE TOLERANCES ARE EXPECTED TO BE USED BY THE
C             INTEGRATOR IN AN ERROR TEST WHICH ROUGHLY REQUIRES THAT
C                        DABS(LOCAL ERROR)  .LE.  ETOL
C             FOR EACH VECTOR COMPONENT.
C
C      MORDER -- THIS IS THE ORDER OF THE FORMULA WHICH WILL BE USED BY
C             THE INITIAL VALUE METHOD FOR TAKING THE FIRST INTEGRATION
C             STEP.
C
C      SMALL -- THIS IS A SMALL POSITIVE MACHINE DEPENDENT CONSTANT
C             WHICH IS USED FOR PROTECTING AGAINST COMPUTATIONS WITH
C             NUMBERS WHICH ARE TOO SMALL RELATIVE TO THE PRECISION OF
C             FLOATING POINT ARITHMETIC.  SMALL  SHOULD BE SET TO
C             (APPROXIMATELY) THE SMALLEST POSITIVE DOUBLE PRECISION
C             NUMBER SUCH THAT  (1.+SMALL) .GT. 1.  ON THE MACHINE BEING
C             USED. THE QUANTITY  SMALL**(3/8)  IS USED IN COMPUTING
C             INCREMENTS OF VARIABLES FOR APPROXIMATING DERIVATIVES BY
C             DIFFERENCES.  ALSO THE ALGORITHM WILL NOT COMPUTE A
C             STARTING STEP LENGTH WHICH IS SMALLER THAN
C             100*SMALL*DABS(A).
C
C      BIG -- THIS IS A LARGE POSITIVE MACHINE DEPENDENT CONSTANT WHICH
C             IS USED FOR PREVENTING MACHINE OVERFLOWS. A REASONABLE
C             CHOICE IS TO SET BIG TO (APPROXIMATELY) THE SQUARE ROOT OF
C             THE LARGEST DOUBLE PRECISION NUMBER WHICH CAN BE HELD IN
C             THE MACHINE.
C
C      SPY(*),PV(*),YP(*),SF(*) -- THESE ARE DOUBLE PRECISION WORK
C             ARRAYS OF LENGTH NEQ WHICH PROVIDE THE ROUTINE WITH NEEDED
C             STORAGE SPACE.
C
C      RPAR,IPAR -- THESE ARE PARAMETER ARRAYS, OF DOUBLE PRECISION AND
C             INTEGER TYPE, RESPECTIVELY, WHICH CAN BE USED FOR
C             COMMUNICATION BETWEEN YOUR PROGRAM AND THE DF SUBROUTINE.
C             THEY ARE NOT USED OR ALTERED BY DHSTRT.
C
C **********************************************************************
C  ON OUTPUT  (AFTER THE RETURN FROM DHSTRT),
C
C      H -- IS AN APPROPRIATE STARTING STEP SIZE TO BE ATTEMPTED BY THE
C             DIFFERENTIAL EQUATION METHOD.
C
C           ALL PARAMETERS IN THE CALL LIST REMAIN UNCHANGED EXCEPT FOR
C           THE WORKING ARRAYS SPY(*),PV(*),YP(*), AND SF(*).
C
C **********************************************************************
C***ROUTINES CALLED  DVNORM
C***END PROLOGUE  DHSTRT
C
      INTEGER IPAR, J, K, LK, MIN0, MORDER, NEQ
      DOUBLE PRECISION A, ABSDX, B, BIG, DA, DABS, DBLE, DELF, DELY,
     *      DFDUB, DFDXB, DLOG10, DMAX1, DMIN1, DSIGN, DSQRT, DVNORM,
     *      DX, DY, ETOL, FBND, H, PV, RELPER, RPAR, SF, SMALL, SPY,
     *      SRYDPB, TOLEXP, TOLMIN, TOLP, TOLSUM, Y, YDPB, YP, YPRIME
      DIMENSION Y(NEQ),YPRIME(NEQ),ETOL(NEQ),SPY(NEQ),PV(NEQ),YP(NEQ),
     *          SF(NEQ),RPAR(1),IPAR(1)
      EXTERNAL DF
C
C     ..................................................................
C
C***FIRST EXECUTABLE STATEMENT  DHSTRT
C     BEGIN BLOCK PERMITTING ...EXITS TO 160
         DX = B - A
         ABSDX = DABS(DX)
         RELPER = SMALL**0.375D0
C
C        ...............................................................
C
C             COMPUTE AN APPROXIMATE BOUND (DFDXB) ON THE PARTIAL
C             DERIVATIVE OF THE EQUATION WITH RESPECT TO THE
C             INDEPENDENT VARIABLE. PROTECT AGAINST AN OVERFLOW.
C             ALSO COMPUTE A BOUND (FBND) ON THE FIRST DERIVATIVE
C             LOCALLY.
C
         DA = DSIGN(DMAX1(DMIN1(RELPER*DABS(A),ABSDX),
     *                    100.0D0*SMALL*DABS(A)),DX)
         IF (DA .EQ. 0.0D0) DA = RELPER*DX
         CALL DF(A+DA,Y,SF,RPAR,IPAR)
         DO 10 J = 1, NEQ
            YP(J) = SF(J) - YPRIME(J)
   10    CONTINUE
         DELF = DVNORM(YP,NEQ)
         DFDXB = BIG
         IF (DELF .LT. BIG*DABS(DA)) DFDXB = DELF/DABS(DA)
         FBND = DVNORM(SF,NEQ)
C
C        ...............................................................
C
C             COMPUTE AN ESTIMATE (DFDUB) OF THE LOCAL LIPSCHITZ
C             CONSTANT FOR THE SYSTEM OF DIFFERENTIAL EQUATIONS. THIS
C             ALSO REPRESENTS AN ESTIMATE OF THE NORM OF THE JACOBIAN
C             LOCALLY.  THREE ITERATIONS (TWO WHEN NEQ=1) ARE USED TO
C             ESTIMATE THE LIPSCHITZ CONSTANT BY NUMERICAL DIFFERENCES.
C             THE FIRST PERTURBATION VECTOR IS BASED ON THE INITIAL
C             DERIVATIVES AND DIRECTION OF INTEGRATION. THE SECOND
C             PERTURBATION VECTOR IS FORMED USING ANOTHER EVALUATION OF
C             THE DIFFERENTIAL EQUATION.  THE THIRD PERTURBATION VECTOR
C             IS FORMED USING PERTURBATIONS BASED ONLY ON THE INITIAL
C             VALUES. COMPONENTS THAT ARE ZERO ARE ALWAYS CHANGED TO
C             NON-ZERO VALUES (EXCEPT ON THE FIRST ITERATION). WHEN
C             INFORMATION IS AVAILABLE, CARE IS TAKEN TO ENSURE THAT
C             COMPONENTS OF THE PERTURBATION VECTOR HAVE SIGNS WHICH ARE
C             CONSISTENT WITH THE SLOPES OF LOCAL SOLUTION CURVES.
C             ALSO CHOOSE THE LARGEST BOUND (FBND) FOR THE FIRST
C             DERIVATIVE.
C
C                               PERTURBATION VECTOR SIZE IS HELD
C                               CONSTANT FOR ALL ITERATIONS. COMPUTE
C                               THIS CHANGE FROM THE
C                                       SIZE OF THE VECTOR OF INITIAL
C                                       VALUES.
         DELY = RELPER*DVNORM(Y,NEQ)
         IF (DELY .EQ. 0.0D0) DELY = RELPER
         DELY = DSIGN(DELY,DX)
         DELF = DVNORM(YPRIME,NEQ)
         FBND = DMAX1(FBND,DELF)
         IF (DELF .EQ. 0.0D0) GO TO 30
C           USE INITIAL DERIVATIVES FOR FIRST PERTURBATION
            DO 20 J = 1, NEQ
               SPY(J) = YPRIME(J)
               YP(J) = YPRIME(J)
   20       CONTINUE
         GO TO 50
   30    CONTINUE
C           CANNOT HAVE A NULL PERTURBATION VECTOR
            DO 40 J = 1, NEQ
               SPY(J) = 0.0D0
               YP(J) = 1.0D0
   40       CONTINUE
            DELF = DVNORM(YP,NEQ)
   50    CONTINUE
C
         DFDUB = 0.0D0
         LK = MIN0(NEQ+1,3)
         DO 140 K = 1, LK
C           DEFINE PERTURBED VECTOR OF INITIAL VALUES
            DO 60 J = 1, NEQ
               PV(J) = Y(J) + DELY*(YP(J)/DELF)
   60       CONTINUE
            IF (K .EQ. 2) GO TO 80
C              EVALUATE DERIVATIVES ASSOCIATED WITH PERTURBED
C              VECTOR  AND  COMPUTE CORRESPONDING DIFFERENCES
               CALL DF(A,PV,YP,RPAR,IPAR)
               DO 70 J = 1, NEQ
                  PV(J) = YP(J) - YPRIME(J)
   70          CONTINUE
            GO TO 100
   80       CONTINUE
C              USE A SHIFTED VALUE OF THE INDEPENDENT VARIABLE
C                                    IN COMPUTING ONE ESTIMATE
               CALL DF(A+DA,PV,YP,RPAR,IPAR)
               DO 90 J = 1, NEQ
                  PV(J) = YP(J) - SF(J)
   90          CONTINUE
  100       CONTINUE
C           CHOOSE LARGEST BOUNDS ON THE FIRST DERIVATIVE
C                          AND A LOCAL LIPSCHITZ CONSTANT
            FBND = DMAX1(FBND,DVNORM(YP,NEQ))
            DELF = DVNORM(PV,NEQ)
C        ...EXIT
            IF (DELF .GE. BIG*DABS(DELY)) GO TO 150
            DFDUB = DMAX1(DFDUB,DELF/DABS(DELY))
C     ......EXIT
            IF (K .EQ. LK) GO TO 160
C           CHOOSE NEXT PERTURBATION VECTOR
            IF (DELF .EQ. 0.0D0) DELF = 1.0D0
            DO 130 J = 1, NEQ
               IF (K .EQ. 2) GO TO 110
                  DY = DABS(PV(J))
                  IF (DY .EQ. 0.0D0) DY = DELF
               GO TO 120
  110          CONTINUE
                  DY = Y(J)
                  IF (DY .EQ. 0.0D0) DY = DELY/RELPER
  120          CONTINUE
               IF (SPY(J) .EQ. 0.0D0) SPY(J) = YP(J)
               IF (SPY(J) .NE. 0.0D0) DY = DSIGN(DY,SPY(J))
               YP(J) = DY
  130       CONTINUE
            DELF = DVNORM(YP,NEQ)
  140    CONTINUE
  150    CONTINUE
C
C        PROTECT AGAINST AN OVERFLOW
         DFDUB = BIG
  160 CONTINUE
C
C     ..................................................................
C
C          COMPUTE A BOUND (YDPB) ON THE NORM OF THE SECOND DERIVATIVE
C
      YDPB = DFDXB + DFDUB*FBND
C
C     ..................................................................
C
C          DEFINE THE TOLERANCE PARAMETER UPON WHICH THE STARTING STEP
C          SIZE IS TO BE BASED.  A VALUE IN THE MIDDLE OF THE ERROR
C          TOLERANCE RANGE IS SELECTED.
C
      TOLMIN = BIG
      TOLSUM = 0.0D0
      DO 170 K = 1, NEQ
         TOLEXP = DLOG10(ETOL(K))
         TOLMIN = DMIN1(TOLMIN,TOLEXP)
         TOLSUM = TOLSUM + TOLEXP
  170 CONTINUE
      TOLP = 10.0D0
     *       **(0.5D0*(TOLSUM/DBLE(FLOAT(NEQ)) + TOLMIN)
     *          /DBLE(FLOAT(MORDER+1)))
C
C     ..................................................................
C
C          COMPUTE A STARTING STEP SIZE BASED ON THE ABOVE FIRST AND
C          SECOND DERIVATIVE INFORMATION
C
C                            RESTRICT THE STEP LENGTH TO BE NOT BIGGER
C                            THAN DABS(B-A).   (UNLESS  B  IS TOO CLOSE
C                            TO  A)
      H = ABSDX
C
      IF (YDPB .NE. 0.0D0 .OR. FBND .NE. 0.0D0) GO TO 180
C
C        BOTH FIRST DERIVATIVE TERM (FBND) AND SECOND
C                     DERIVATIVE TERM (YDPB) ARE ZERO
         IF (TOLP .LT. 1.0D0) H = ABSDX*TOLP
      GO TO 200
  180 CONTINUE
C
      IF (YDPB .NE. 0.0D0) GO TO 190
C
C        ONLY SECOND DERIVATIVE TERM (YDPB) IS ZERO
         IF (TOLP .LT. FBND*ABSDX) H = TOLP/FBND
      GO TO 200
  190 CONTINUE
C
C        SECOND DERIVATIVE TERM (YDPB) IS NON-ZERO
         SRYDPB = DSQRT(0.5D0*YDPB)
         IF (TOLP .LT. SRYDPB*ABSDX) H = TOLP/SRYDPB
  200 CONTINUE
C
C     FURTHER RESTRICT THE STEP LENGTH TO BE NOT
C                               BIGGER THAN  1/DFDUB
      IF (H*DFDUB .GT. 1.0D0) H = 1.0D0/DFDUB
C
C     FINALLY, RESTRICT THE STEP LENGTH TO BE NOT
C     SMALLER THAN  100*SMALL*DABS(A).  HOWEVER, IF
C     A=0. AND THE COMPUTED H UNDERFLOWED TO ZERO,
C     THE ALGORITHM RETURNS  SMALL*DABS(B)  FOR THE
C                                     STEP LENGTH.
      H = DMAX1(H,100.0D0*SMALL*DABS(A))
      IF (H .EQ. 0.0D0) H = SMALL*DABS(B)
C
C     NOW SET DIRECTION OF INTEGRATION
      H = DSIGN(H,DX)
C
      RETURN
      END
      SUBROUTINE DINTYD(T,K,YH,NYH,DKY,IFLAG)
C***BEGIN PROLOGUE  DINTYD
C***REFER TO  DDEBDF
C   DINTYD APPROXIMATES THE SOLUTION AND DERIVATIVES AT T BY POLYNOMIAL
C   INTERPOLATION. MUST BE USED IN CONJUNCTION WITH THE INTEGRATOR
C   PACKAGE DDEBDF.
C-----------------------------------------------------------------------
C DINTYD COMPUTES INTERPOLATED VALUES OF THE K-TH DERIVATIVE OF THE
C DEPENDENT VARIABLE VECTOR Y, AND STORES IT IN DKY.
C THIS ROUTINE IS CALLED BY DDEBDF WITH K = 0,1 AND T = TOUT, BUT MAY
C ALSO BE CALLED BY THE USER FOR ANY K UP TO THE CURRENT ORDER.
C (SEE DETAILED INSTRUCTIONS IN LSODE USAGE DOCUMENTATION.)
C-----------------------------------------------------------------------
C THE COMPUTED VALUES IN DKY ARE GOTTEN BY INTERPOLATION USING THE
C NORDSIECK HISTORY ARRAY YH.  THIS ARRAY CORRESPONDS UNIQUELY TO A
C VECTOR-VALUED POLYNOMIAL OF DEGREE NQCUR OR LESS, AND DKY IS SET
C TO THE K-TH DERIVATIVE OF THIS POLYNOMIAL AT T.
C THE FORMULA FOR DKY IS..
C              Q
C  DKY(I)  =  SUM  C(J,K) * (T - TN)**(J-K) * H**(-J) * YH(I,J+1)
C             J=K
C WHERE  C(J,K) = J*(J-1)*...*(J-K+1), Q = NQCUR, TN = TCUR, H = HCUR.
C THE QUANTITIES  NQ = NQCUR, L = NQ+1, N = NEQ, TN, AND H ARE
C COMMUNICATED BY COMMON.  THE ABOVE SUM IS DONE IN REVERSE ORDER.
C IFLAG IS RETURNED NEGATIVE IF EITHER K OR T IS OUT OF BOUNDS.
C-----------------------------------------------------------------------
C***ROUTINES CALLED  (NONE)
C***COMMON BLOCKS    DEBDF1
C***END PROLOGUE  DINTYD
C
      INTEGER I, IC, IER, IFLAG, IOWND, IOWNS, J, JB, JB2, JJ, JJ1,
     *      JP1, JSTART, K, KFLAG, L, MAXORD, METH, MITER, N, NFE,
     *      NJE, NQ, NQU, NST, NYH
      DOUBLE PRECISION C, DBLE, DKY, EL0, H, HMIN, HMXI, HU, R, ROWND,
     *      ROWNS, S, T, TN, TP, UROUND, YH
      DIMENSION YH(NYH,1),DKY(1)
      COMMON /DEBDF1/ ROWND,ROWNS(210),EL0,H,HMIN,HMXI,HU,TN,UROUND,
     *                IOWND(14),IOWNS(6),IER,JSTART,KFLAG,L,METH,MITER,
     *                MAXORD,N,NQ,NST,NFE,NJE,NQU
C
C
C***FIRST EXECUTABLE STATEMENT  DINTYD
C     BEGIN BLOCK PERMITTING ...EXITS TO 130
         IFLAG = 0
         IF (K .LT. 0 .OR. K .GT. NQ) GO TO 110
            TP = TN - HU*(1.0D0 + 100.0D0*UROUND)
            IF ((T - TP)*(T - TN) .LE. 0.0D0) GO TO 10
               IFLAG = -2
C     .........EXIT
               GO TO 130
   10       CONTINUE
C
            S = (T - TN)/H
            IC = 1
            IF (K .EQ. 0) GO TO 30
               JJ1 = L - K
               DO 20 JJ = JJ1, NQ
                  IC = IC*JJ
   20          CONTINUE
   30       CONTINUE
            C = DBLE(FLOAT(IC))
            DO 40 I = 1, N
               DKY(I) = C*YH(I,L)
   40       CONTINUE
            IF (K .EQ. NQ) GO TO 90
               JB2 = NQ - K
               DO 80 JB = 1, JB2
                  J = NQ - JB
                  JP1 = J + 1
                  IC = 1
                  IF (K .EQ. 0) GO TO 60
                     JJ1 = JP1 - K
                     DO 50 JJ = JJ1, J
                        IC = IC*JJ
   50                CONTINUE
   60             CONTINUE
                  C = DBLE(FLOAT(IC))
                  DO 70 I = 1, N
                     DKY(I) = C*YH(I,JP1) + S*DKY(I)
   70             CONTINUE
   80          CONTINUE
C     .........EXIT
               IF (K .EQ. 0) GO TO 130
   90       CONTINUE
            R = H**(-K)
            DO 100 I = 1, N
               DKY(I) = R*DKY(I)
  100       CONTINUE
         GO TO 120
  110    CONTINUE
C
            IFLAG = -1
  120    CONTINUE
  130 CONTINUE
      RETURN
C     ----------------------- END OF SUBROUTINE DINTYD
C     -----------------------
      END
      SUBROUTINE DLSOD(DF,NEQ,T,Y,TOUT,RTOL,ATOL,IDID,YPOUT,YH,YH1,EWT,
     *                 SAVF,ACOR,WM,IWM,DJAC,INTOUT,TSTOP,TOLFAC,DELSGN,
     *                 RPAR,IPAR)
C***BEGIN PROLOGUE  DLSOD
C***REFER TO  DDEBDF
C   DDEBDF  MERELY ALLOCATES STORAGE FOR  DLSOD  TO RELIEVE THE USER OF
C   THE INCONVENIENCE OF A LONG CALL LIST.  CONSEQUENTLY  DLSOD  IS USED
C   AS DESCRIBED IN THE COMMENTS FOR  DDEBDF .
C***ROUTINES CALLED  DSTOD,DINTYD,DVNRMS,DHSTRT,D1MACH,XERRWV
C***COMMON BLOCKS    DEBDF1
C***END PROLOGUE  DLSOD
C
      INTEGER IBAND, IBEGIN, IDID, IER, IINTEG, IJAC, INIT, INTFLG,
     *      IOWNS, IPAR, IQUIT, ITOL, ITSTOP, IWM, JSTART, K, KFLAG,
     *      KSTEPS, L, LACOR, LDUM, LEWT, LSAVF, LTOL, LWM, LYH, MAXNUM,
     *      MAXORD, METH, MITER, N, NATOLP, NEQ, NFE, NJE, NQ, NQU,
     *      NRTOLP, NST
      REAL RTEMP1, RTEMP2
      DOUBLE PRECISION ABSDEL, ACOR, ATOL, BIG, D1MACH, DABS, DEL,
     *      DELSGN, DMAX1, DMIN1, DSIGN, DSQRT, DT, DVNRMS, EL0, EWT,
     *      H, HA, HMIN, HMXI, HU, ROWNS, RPAR, RTOL, SAVF, T, TOL,
     *      TOLD, TOLFAC, TOUT, TSTOP, U, WM, X, Y, YH, YH1, YPOUT
      LOGICAL INTOUT
C
      DIMENSION Y(NEQ),YPOUT(NEQ),YH(NEQ,6),YH1(1),EWT(NEQ),SAVF(NEQ),
     *          ACOR(NEQ),WM(1),IWM(1),RTOL(1),ATOL(1),RPAR(1),IPAR(1)
C
C
      COMMON /DEBDF1/ TOLD,ROWNS(210),EL0,H,HMIN,HMXI,HU,X,U,IQUIT,INIT,
     *                LYH,LEWT,LACOR,LSAVF,LWM,KSTEPS,IBEGIN,ITOL,
     *                IINTEG,ITSTOP,IJAC,IBAND,IOWNS(6),IER,JSTART,
     *                KFLAG,LDUM,METH,MITER,MAXORD,N,NQ,NST,NFE,NJE,NQU
C
      EXTERNAL DF,DJAC
C
C     ..................................................................
C
C       THE EXPENSE OF SOLVING THE PROBLEM IS MONITORED BY COUNTING THE
C       NUMBER OF  STEPS ATTEMPTED. WHEN THIS EXCEEDS  MAXNUM, THE
C       COUNTER IS RESET TO ZERO AND THE USER IS INFORMED ABOUT POSSIBLE
C       EXCESSIVE WORK.
C
      DATA MAXNUM /5000/
C
C     ..................................................................
C
C***FIRST EXECUTABLE STATEMENT  DLSOD
      IF (IBEGIN .NE. 0) GO TO 10
C
C        ON THE FIRST CALL , PERFORM INITIALIZATION --
C               DEFINE THE MACHINE UNIT ROUNDOFF QUANTITY  U  BY CALLING
C               THE FUNCTION ROUTINE  D1MACH. THE USER MUST MAKE SURE
C               THAT THE VALUES SET IN D1MACH ARE RELEVANT TO THE
C               COMPUTER BEING USED.
C
         U = D1MACH(4)
C        -- SET ASSOCIATED MACHINE DEPENDENT PARAMETER
         WM(1) = DSQRT(U)
C        -- SET TERMINATION FLAG
         IQUIT = 0
C        -- SET INITIALIZATION INDICATOR
         INIT = 0
C        -- SET COUNTER FOR ATTEMPTED STEPS
         KSTEPS = 0
C        -- SET INDICATOR FOR INTERMEDIATE-OUTPUT
         INTOUT = .FALSE.
C        -- SET START INDICATOR FOR DSTOD CODE
         JSTART = 0
C        -- SET BDF METHOD INDICATOR
         METH = 2
C        -- SET MAXIMUM ORDER FOR BDF METHOD
         MAXORD = 5
C        -- SET ITERATION MATRIX INDICATOR
C
         IF (IJAC .EQ. 0 .AND. IBAND .EQ. 0) MITER = 2
         IF (IJAC .EQ. 1 .AND. IBAND .EQ. 0) MITER = 1
         IF (IJAC .EQ. 0 .AND. IBAND .EQ. 1) MITER = 5
         IF (IJAC .EQ. 1 .AND. IBAND .EQ. 1) MITER = 4
C
C        -- SET OTHER NECESSARY ITEMS IN COMMON BLOCK
         N = NEQ
         NST = 0
         NJE = 0
         HMXI = 0.0D0
         NQ = 1
         H = 1.0D0
C        -- RESET IBEGIN FOR SUBSEQUENT CALLS
         IBEGIN = 1
   10 CONTINUE
C
C     ..................................................................
C
C           CHECK VALIDITY OF INPUT PARAMATERS ON EACH ENTRY
C
      IF (NEQ .GE. 1) GO TO 20
         WRITE (6,1000) NEQ
 1000 FORMAT('DDEBDF - THE NUMBER OF EQUATIONS NEQ MUST BE A POSITIVE'/,
     *'INTEGER.  YOU HAVE CALLED THE CODE WITH  NEQ = ',I3)
         IDID = -33
   20 CONTINUE
C
      NRTOLP = 0
      NATOLP = 0
      DO 70 K = 1, NEQ
C        BEGIN BLOCK PERMITTING ...EXITS TO 60
            IF (NRTOLP .GT. 0) GO TO 50
               IF (RTOL(K) .GE. 0.0D0) GO TO 30
                  RTEMP1 = RTOL(K)
                  WRITE (6,1100) K,RTEMP1 
 1100 FORMAT('DDEBDF - THE RELATIVE ERROR TOLERANCES RTOL MUST BE'/,
     *'NON-NEGATIVE.  YOU HAVE CALLED THE CODE WITH  RTOL(',I3,') = ',
     *1PG12.4,/'IN THE CASE OF  VECTOR ERROR TOLERANCES, NO FURTHER'/,
     *'CHECKING OF RTOL COMPONENTS IS DONE.')
                  IDID = -33
C     ............EXIT
                  IF (NATOLP .GT. 0) GO TO 80
                  NRTOLP = 1
               GO TO 40
   30          CONTINUE
C        .........EXIT
                  IF (NATOLP .GT. 0) GO TO 60
   40          CONTINUE
   50       CONTINUE
C        ...EXIT
            IF (ATOL(K) .GE. 0.0D0) GO TO 60
            RTEMP1 = ATOL(K)
            WRITE(6,1200) K,RTEMP1
 1200 FORMAT('DDEBDF - THE ABSOLUTE ERROR TOLERANCES ATOL MUST BE'/,
     *'NON-NEGATIVE.  YOU HAVE CALLED THE CODE WITH  ATOL(',I2,') = ',
     *1PG12.4,/'IN THE CASE OF VECTOR ERROR TOLERANCES, NO FURTHER'/,
     *'CHECKING OF ATOL COMPONENTS IS DONE.')
            IDID = -33
C     ......EXIT
            IF (NRTOLP .GT. 0) GO TO 80
            NATOLP = 1
   60    CONTINUE
C     ...EXIT
         IF (ITOL .EQ. 0) GO TO 80
   70 CONTINUE
   80 CONTINUE
C
      IF (ITSTOP .NE. 1) GO TO 90
      IF (DSIGN(1.0D0,TOUT-T) .EQ. DSIGN(1.0D0,TSTOP-T)
     *    .AND. DABS(TOUT-T) .LE. DABS(TSTOP-T)) GO TO 90
         RTEMP1 = TOUT
         RTEMP2 = TSTOP
         WRITE (6,1300) RTEMP1,RTEMP2
 1300 FORMAT('DDEBDF - YOU HAVE CALLED THE CODE WITH TOUT = ',1PG12.4,
     */'BUT YOU HAVE ALSO TOLD THE CODE (INFO(4)=1) NOT TO INTEGRATE'/,
     *'PAST THE POINT TSTOP = ',1PG12.4,' THESE INSTRUCTIONS CONFLICT.')
         IDID = -33
   90 CONTINUE
C
      IF (INIT .EQ. 0) GO TO 130
C        CHECK SOME CONTINUATION POSSIBILITIES
         IF (T .NE. TOUT) GO TO 100
            RTEMP1 = T
            WRITE (6,1400) RTEMP1
 1400 FORMAT('DDEBDF - YOU HAVE CALLED THE CODE WITH  T = TOUT  AT'/,
     *'T = ',1PG12.4,' THIS IS NOT ALLOWED ON CONTINUATION CALLS.')
            IDID = -33
  100    CONTINUE
C
         IF (T .EQ. TOLD) GO TO 110
            RTEMP1 = TOLD
            RTEMP2 = T
            WRITE (6,1500) RTEMP1,RTEMP2
 1500 FORMAT('DDEBDF - YOU HAVE CHANGED THE VALUE OF T FROM ',1PG12.4,
     *' TO ',1PG12.4,' THIS IS NOT ALLOWED ON CONTINUATION CALLS.')
            IDID = -33
  110    CONTINUE
C
         IF (INIT .EQ. 1) GO TO 120
         IF (DELSGN*(TOUT - T) .GE. 0.0D0) GO TO 120
            RTEMP1 = TOUT
            WRITE (6,1600) RTEMP1
 1600 FORMAT('DDEBDF - BY CALLING THE CODE WITH  TOUT = ',1PG12.4,
     */'YOU ARE ATTEMPTING TO CHANGE THE DIRECTION OF INTEGRATION.'/,
     *'THIS IS NOT ALLOWED  WITHOUT RESTARTING.')
            IDID = -33
  120    CONTINUE
  130 CONTINUE
C
      IF (IDID .NE. (-33)) GO TO 160
         IF (IQUIT .EQ. (-33)) GO TO 140
C
C           INVALID INPUT DETECTED
            IQUIT = -33
            IBEGIN = -1
         GO TO 150
  140    CONTINUE
C
            WRITE (6,1700)
 1700 FORMAT('DDEBDF - INVALID INPUT WAS DETECTED ON SUCCESSIVE'/,
     *'ENTRIES.  IT IS IMPOSSIBLE TO PROCEED BECAUSE YOU HAVE NOT'/,
     *'CORRECTED THE PROBLEM, SO EXECUTION IS BEING TERMINATED.')
  150    CONTINUE
      GO TO 470
  160 CONTINUE
C
C        ...............................................................
C
C             RTOL = ATOL = 0. IS ALLOWED AS VALID INPUT AND INTERPRETED
C             AS ASKING FOR THE MOST ACCURATE SOLUTION POSSIBLE. IN THIS
C             CASE, THE RELATIVE ERROR TOLERANCE RTOL IS RESET TO THE
C             SMALLEST VALUE 100*U WHICH IS LIKELY TO BE REASONABLE FOR
C             THIS METHOD AND MACHINE
C
         DO 180 K = 1, NEQ
            IF (RTOL(K) + ATOL(K) .GT. 0.0D0) GO TO 170
               RTOL(K) = 100.0D0*U
               IDID = -2
  170       CONTINUE
C        ...EXIT
            IF (ITOL .EQ. 0) GO TO 190
  180    CONTINUE
  190    CONTINUE
C
         IF (IDID .NE. (-2)) GO TO 200
C           RTOL=ATOL=0 ON INPUT, SO RTOL IS CHANGED TO A
C                                    SMALL POSITIVE VALUE
            IBEGIN = -1
         GO TO 460
  200    CONTINUE
C           BEGIN BLOCK PERMITTING ...EXITS TO 450
C              BEGIN BLOCK PERMITTING ...EXITS TO 430
C                 BEGIN BLOCK PERMITTING ...EXITS TO 260
C                    BEGIN BLOCK PERMITTING ...EXITS TO 230
C
C                       BRANCH ON STATUS OF INITIALIZATION INDICATOR
C                              INIT=0 MEANS INITIAL DERIVATIVES AND
C                              NOMINAL STEP SIZE
C                                     AND DIRECTION NOT YET SET
C                              INIT=1 MEANS NOMINAL STEP SIZE AND
C                              DIRECTION NOT YET SET INIT=2 MEANS NO
C                              FUTHER INITIALIZATION REQUIRED
C
                        IF (INIT .EQ. 0) GO TO 210
C                    ......EXIT
                           IF (INIT .EQ. 1) GO TO 230
C                 .........EXIT
                           GO TO 260
  210                   CONTINUE
C
C                       ................................................
C
C                            MORE INITIALIZATION --
C                                                -- EVALUATE INITIAL
C                                                DERIVATIVES
C
                        INIT = 1
                        CALL DF(T,Y,YH(1,2),RPAR,IPAR)
                        NFE = 1
C                    ...EXIT
                        IF (T .NE. TOUT) GO TO 230
                        IDID = 2
                        DO 220 L = 1, NEQ
                           YPOUT(L) = YH(L,2)
  220                   CONTINUE
                        TOLD = T
C           ............EXIT
                        GO TO 450
  230                CONTINUE
C
C                    -- COMPUTE INITIAL STEP SIZE
C                    -- SAVE DSIGN OF INTEGRATION DIRECTION
C                    -- SET INDEPENDENT AND DEPENDENT VARIABLES
C                                         X AND YH(*) FOR DSTOD
C
                     LTOL = 1
                     DO 240 L = 1, NEQ
                        IF (ITOL .EQ. 1) LTOL = L
                        TOL = RTOL(LTOL)*DABS(Y(L)) + ATOL(LTOL)
                        IF (TOL .EQ. 0.0D0) GO TO 390
                        EWT(L) = TOL
  240                CONTINUE
C
                     BIG = DSQRT(D1MACH(2))
                     CALL DHSTRT(DF,NEQ,T,TOUT,Y,YH(1,2),EWT,1,U,BIG,
     *                           YH(1,3),YH(1,4),YH(1,5),YH(1,6),RPAR,
     *                           IPAR,H)
C
                     DELSGN = DSIGN(1.0D0,TOUT-T)
                     X = T
                     DO 250 L = 1, NEQ
                        YH(L,1) = Y(L)
                        YH(L,2) = H*YH(L,2)
  250                CONTINUE
                     INIT = 2
  260             CONTINUE
C
C                 ......................................................
C
C                    ON EACH CALL SET INFORMATION WHICH DETERMINES THE
C                    ALLOWED INTERVAL OF INTEGRATION BEFORE RETURNING
C                    WITH AN ANSWER AT TOUT
C
                  DEL = TOUT - T
                  ABSDEL = DABS(DEL)
C
C                 ......................................................
C
C                    IF ALREADY PAST OUTPUT POINT, INTERPOLATE AND
C                    RETURN
C
  270             CONTINUE
C                    BEGIN BLOCK PERMITTING ...EXITS TO 400
C                       BEGIN BLOCK PERMITTING ...EXITS TO 380
                           IF (DABS(X-T) .LT. ABSDEL) GO TO 290
                              CALL DINTYD(TOUT,0,YH,NEQ,Y,INTFLG)
                              CALL DINTYD(TOUT,1,YH,NEQ,YPOUT,INTFLG)
                              IDID = 3
                              IF (X .NE. TOUT) GO TO 280
                                 IDID = 2
                                 INTOUT = .FALSE.
  280                         CONTINUE
                              T = TOUT
                              TOLD = T
C           ..................EXIT
                              GO TO 450
  290                      CONTINUE
C
C                          IF CANNOT GO PAST TSTOP AND SUFFICIENTLY
C                          CLOSE, EXTRAPOLATE AND RETURN
C
                           IF (ITSTOP .NE. 1) GO TO 310
                           IF (DABS(TSTOP-X) .GE. 100.0D0*U*DABS(X))
     *                        GO TO 310
                              DT = TOUT - X
                              DO 300 L = 1, NEQ
                                 Y(L) = YH(L,1) + (DT/H)*YH(L,2)
  300                         CONTINUE
                              CALL DF(TOUT,Y,YPOUT,RPAR,IPAR)
                              NFE = NFE + 1
                              IDID = 3
                              T = TOUT
                              TOLD = T
C           ..................EXIT
                              GO TO 450
  310                      CONTINUE
C
                           IF (IINTEG .EQ. 0 .OR. .NOT.INTOUT) GO TO 320
C
C                             INTERMEDIATE-OUTPUT MODE
C
                              IDID = 1
                           GO TO 370
  320                      CONTINUE
C
C                          .............................................
C
C                               MONITOR NUMBER OF STEPS ATTEMPTED
C
                           IF (KSTEPS .LE. MAXNUM) GO TO 330
C
C                             A SIGNIFICANT AMOUNT OF WORK HAS BEEN
C                             EXPENDED
                              IDID = -1
                              KSTEPS = 0
                              IBEGIN = -1
                           GO TO 370
  330                      CONTINUE
C
C                             ..........................................
C
C                                LIMIT STEP SIZE AND SET WEIGHT VECTOR
C
                              HMIN = 100.0D0*U*DABS(X)
                              HA = DMAX1(DABS(H),HMIN)
                              IF (ITSTOP .EQ. 1)
     *                           HA = DMIN1(HA,DABS(TSTOP-X))
                              H = DSIGN(HA,H)
                              LTOL = 1
                              DO 340 L = 1, NEQ
                                 IF (ITOL .EQ. 1) LTOL = L
                                 EWT(L) = RTOL(LTOL)*DABS(YH(L,1))
     *                                    + ATOL(LTOL)
C                       .........EXIT
                                 IF (EWT(L) .LE. 0.0D0) GO TO 380
  340                         CONTINUE
                              TOLFAC = U*DVNRMS(NEQ,YH,EWT)
C                    .........EXIT
                              IF (TOLFAC .LE. 1.0D0) GO TO 400
C
C                             TOLERANCES TOO SMALL
                              IDID = -2
                              TOLFAC = 2.0D0*TOLFAC
                              RTOL(1) = TOLFAC*RTOL(1)
                              ATOL(1) = TOLFAC*ATOL(1)
                              IF (ITOL .EQ. 0) GO TO 360
                                 DO 350 L = 2, NEQ
                                    RTOL(L) = TOLFAC*RTOL(L)
                                    ATOL(L) = TOLFAC*ATOL(L)
  350                            CONTINUE
  360                         CONTINUE
                              IBEGIN = -1
  370                      CONTINUE
C              ............EXIT
                           GO TO 430
  380                   CONTINUE
C
C                       RELATIVE ERROR CRITERION INAPPROPRIATE
  390                   CONTINUE
                        IDID = -3
                        IBEGIN = -1
C              .........EXIT
                        GO TO 430
  400                CONTINUE
C
C                    ...................................................
C
C                         TAKE A STEP
C
                     CALL DSTOD(NEQ,Y,YH,NEQ,YH1,EWT,SAVF,ACOR,WM,IWM,
     *                          DF,DJAC,RPAR,IPAR)
C
                     JSTART = -2
                     INTOUT = .TRUE.
                  IF (KFLAG .EQ. 0) GO TO 270
C
C                 ......................................................
C
                  IF (KFLAG .EQ. -1) GO TO 410
C
C                    REPEATED CORRECTOR CONVERGENCE FAILURES
                     IDID = -6
                     IBEGIN = -1
                  GO TO 420
  410             CONTINUE
C
C                    REPEATED ERROR TEST FAILURES
                     IDID = -7
                     IBEGIN = -1
  420             CONTINUE
  430          CONTINUE
C
C              .........................................................
C
C                                     STORE VALUES BEFORE RETURNING TO
C                                     DDEBDF
               DO 440 L = 1, NEQ
                  Y(L) = YH(L,1)
                  YPOUT(L) = YH(L,2)/H
  440          CONTINUE
               T = X
               TOLD = T
               INTOUT = .FALSE.
  450       CONTINUE
  460    CONTINUE
  470 CONTINUE
      RETURN
      END
      SUBROUTINE DPJAC(NEQ,Y,YH,NYH,EWT,FTEM,SAVF,WM,IWM,DF,DJAC,RPAR,
     *                 IPAR)
C***BEGIN PROLOGUE  DPJAC
C***REFER TO  DDEBDF
C   DPJAC SETS UP THE ITERATION MATRIX (INVOLVING THE JACOBIAN) FOR THE
C   INTEGRATION PACKAGE DDEBDF.
C***ROUTINES CALLED  DVNRMS,DGEFA,DGBFA
C***COMMON BLOCKS    DEBDF1
C***END PROLOGUE  DPJAC
C
      INTEGER I, I1, I2, IER, II, IOWND, IOWNS, IPAR, IWM, J, J1,
     *      JJ, JSTART, KFLAG, L, LENP, MAX0, MAXORD, MBA, MBAND,
     *      MEB1, MEBAND, METH, MIN0, MITER, ML, ML3, MU, N, NEQ,
     *      NFE, NJE, NQ, NQU, NST, NYH
      DOUBLE PRECISION CON, DABS, DBLE, DI, DMAX1, DVNRMS, EL0, EWT,
     *      FAC, FTEM, H, HL0, HMIN, HMXI, HU, R, R0, ROWND, ROWNS,
     *      RPAR, SAVF, SRUR, TN, UROUND, WM, Y, YH, YI, YJ, YJJ
      EXTERNAL DF,DJAC
      DIMENSION Y(1),YH(NYH,2),EWT(1),FTEM(1),SAVF(1),WM(3),IWM(21),
     *          RPAR(1),IPAR(1)
      COMMON /DEBDF1/ ROWND,ROWNS(210),EL0,H,HMIN,HMXI,HU,TN,UROUND,
     *                IOWND(14),IOWNS(6),IER,JSTART,KFLAG,L,METH,MITER,
     *                MAXORD,N,NQ,NST,NFE,NJE,NQU
C     ------------------------------------------------------------------
C      DPJAC IS CALLED BY DSTOD  TO COMPUTE AND PROCESS THE MATRIX
C      P = I - H*EL(1)*J , WHERE J IS AN APPROXIMATION TO THE JACOBIAN.
C      HERE J IS COMPUTED BY THE USER-SUPPLIED ROUTINE DJAC IF
C      MITER = 1 OR 4, OR BY FINITE DIFFERENCING IF MITER = 2, 3, OR 5.
C      IF MITER = 3, A DIAGONAL APPROXIMATION TO J IS USED.
C      J IS STORED IN WM AND REPLACED BY P.  IF MITER .NE. 3, P IS THEN
C      SUBJECTED TO LU DECOMPOSITION IN PREPARATION FOR LATER SOLUTION
C      OF LINEAR SYSTEMS WITH P AS COEFFICIENT MATRIX. THIS IS DONE
C      BY DGEFA IF MITER = 1 OR 2, AND BY DGBFA IF MITER = 4 OR 5.
C
C      IN ADDITION TO VARIABLES DESCRIBED PREVIOUSLY, COMMUNICATION
C      WITH DPJAC USES THE FOLLOWING..
C      Y    = ARRAY CONTAINING PREDICTED VALUES ON ENTRY.
C      FTEM = WORK ARRAY OF LENGTH N (ACOR IN DSTOD ).
C      SAVF = ARRAY CONTAINING DF EVALUATED AT PREDICTED Y.
C      WM   = DOUBLE PRECISION WORK SPACE FOR MATRICES.  ON OUTPUT IT
C      CONTAINS THE
C             INVERSE DIAGONAL MATRIX IF MITER = 3 AND THE LU
C             DECOMPOSITION OF P IF MITER IS 1, 2 , 4, OR 5.
C             STORAGE OF MATRIX ELEMENTS STARTS AT WM(3).
C             WM ALSO CONTAINS THE FOLLOWING MATRIX-RELATED DATA..
C             WM(1) = SQRT(UROUND), USED IN NUMERICAL JACOBIAN
C             INCREMENTS.  WM(2) = H*EL0, SAVED FOR LATER USE IF MITER =
C             3.
C      IWM  = INTEGER WORK SPACE CONTAINING PIVOT INFORMATION, STARTING
C             AT IWM(21), IF MITER IS 1, 2, 4, OR 5.  IWM ALSO CONTAINS
C             THE BAND PARAMETERS ML = IWM(1) AND MU = IWM(2) IF MITER
C             IS 4 OR 5.
C      EL0  = EL(1) (INPUT).
C      IER  = OUTPUT ERROR FLAG,  = 0 IF NO TROUBLE, .NE. 0 IF
C             P MATRIX FOUND TO BE SINGULAR.
C      THIS ROUTINE ALSO USES THE COMMON VARIABLES EL0, H, TN, UROUND,
C      MITER, N, NFE, AND NJE.
C-----------------------------------------------------------------------
C***FIRST EXECUTABLE STATEMENT  DPJAC
C     BEGIN BLOCK PERMITTING ...EXITS TO 240
C        BEGIN BLOCK PERMITTING ...EXITS TO 220
C           BEGIN BLOCK PERMITTING ...EXITS TO 130
C              BEGIN BLOCK PERMITTING ...EXITS TO 70
                  NJE = NJE + 1
                  HL0 = H*EL0
                  GO TO (10,40,90,140,170), MITER
C                 IF MITER = 1, CALL DJAC AND MULTIPLY BY SCALAR.
C                 -----------------------
   10             CONTINUE
                  LENP = N*N
                  DO 20 I = 1, LENP
                     WM(I+2) = 0.0D0
   20             CONTINUE
                  CALL DJAC(TN,Y,WM(3),N,RPAR,IPAR)
                  CON = -HL0
                  DO 30 I = 1, LENP
                     WM(I+2) = WM(I+2)*CON
   30             CONTINUE
C              ...EXIT
                  GO TO 70
C                 IF MITER = 2, MAKE N CALLS TO DF TO APPROXIMATE J.
C                 --------------------
   40             CONTINUE
                  FAC = DVNRMS(N,SAVF,EWT)
                  R0 = 1000.0D0*DABS(H)*UROUND*DBLE(FLOAT(N))*FAC
                  IF (R0 .EQ. 0.0D0) R0 = 1.0D0
                  SRUR = WM(1)
                  J1 = 2
                  DO 60 J = 1, N
                     YJ = Y(J)
                     R = DMAX1(SRUR*DABS(YJ),R0*EWT(J))
                     Y(J) = Y(J) + R
                     FAC = -HL0/R
                     CALL DF(TN,Y,FTEM,RPAR,IPAR)
                     DO 50 I = 1, N
                        WM(I+J1) = (FTEM(I) - SAVF(I))*FAC
   50                CONTINUE
                     Y(J) = YJ
                     J1 = J1 + N
   60             CONTINUE
                  NFE = NFE + N
   70          CONTINUE
C              ADD IDENTITY MATRIX.
C              -------------------------------------------------
               J = 3
               DO 80 I = 1, N
                  WM(J) = WM(J) + 1.0D0
                  J = J + (N + 1)
   80          CONTINUE
C              DO LU DECOMPOSITION ON P.
C              --------------------------------------------
               CALL DGEFA(WM(3),N,N,IWM(21),IER)
C     .........EXIT
               GO TO 240
C              IF MITER = 3, CONSTRUCT A DIAGONAL APPROXIMATION TO J AND
C              P. ---------
   90          CONTINUE
               WM(2) = HL0
               IER = 0
               R = EL0*0.1D0
               DO 100 I = 1, N
                  Y(I) = Y(I) + R*(H*SAVF(I) - YH(I,2))
  100          CONTINUE
               CALL DF(TN,Y,WM(3),RPAR,IPAR)
               NFE = NFE + 1
               DO 120 I = 1, N
                  R0 = H*SAVF(I) - YH(I,2)
                  DI = 0.1D0*R0 - H*(WM(I+2) - SAVF(I))
                  WM(I+2) = 1.0D0
                  IF (DABS(R0) .LT. UROUND*EWT(I)) GO TO 110
C           .........EXIT
                     IF (DABS(DI) .EQ. 0.0D0) GO TO 130
                     WM(I+2) = 0.1D0*R0/DI
  110             CONTINUE
  120          CONTINUE
C     .........EXIT
               GO TO 240
  130       CONTINUE
            IER = -1
C     ......EXIT
            GO TO 240
C           IF MITER = 4, CALL DJAC AND MULTIPLY BY SCALAR.
C           -----------------------
  140       CONTINUE
            ML = IWM(1)
            MU = IWM(2)
            ML3 = 3
            MBAND = ML + MU + 1
            MEBAND = MBAND + ML
            LENP = MEBAND*N
            DO 150 I = 1, LENP
               WM(I+2) = 0.0D0
  150       CONTINUE
            CALL DJAC(TN,Y,WM(ML3),MEBAND,RPAR,IPAR)
            CON = -HL0
            DO 160 I = 1, LENP
               WM(I+2) = WM(I+2)*CON
  160       CONTINUE
C        ...EXIT
            GO TO 220
C           IF MITER = 5, MAKE MBAND CALLS TO DF TO APPROXIMATE J.
C           ----------------
  170       CONTINUE
            ML = IWM(1)
            MU = IWM(2)
            MBAND = ML + MU + 1
            MBA = MIN0(MBAND,N)
            MEBAND = MBAND + ML
            MEB1 = MEBAND - 1
            SRUR = WM(1)
            FAC = DVNRMS(N,SAVF,EWT)
            R0 = 1000.0D0*DABS(H)*UROUND*DBLE(FLOAT(N))*FAC
            IF (R0 .EQ. 0.0D0) R0 = 1.0D0
            DO 210 J = 1, MBA
               DO 180 I = J, N, MBAND
                  YI = Y(I)
                  R = DMAX1(SRUR*DABS(YI),R0*EWT(I))
                  Y(I) = Y(I) + R
  180          CONTINUE
               CALL DF(TN,Y,FTEM,RPAR,IPAR)
               DO 200 JJ = J, N, MBAND
                  Y(JJ) = YH(JJ,1)
                  YJJ = Y(JJ)
                  R = DMAX1(SRUR*DABS(YJJ),R0*EWT(JJ))
                  FAC = -HL0/R
                  I1 = MAX0(JJ-MU,1)
                  I2 = MIN0(JJ+ML,N)
                  II = JJ*MEB1 - ML + 2
                  DO 190 I = I1, I2
                     WM(II+I) = (FTEM(I) - SAVF(I))*FAC
  190             CONTINUE
  200          CONTINUE
  210       CONTINUE
            NFE = NFE + MBA
  220    CONTINUE
C        ADD IDENTITY MATRIX.
C        -------------------------------------------------
         II = MBAND + 2
         DO 230 I = 1, N
            WM(II) = WM(II) + 1.0D0
            II = II + MEBAND
  230    CONTINUE
C        DO LU DECOMPOSITION OF P.
C        --------------------------------------------
         CALL DGBFA(WM(3),MEBAND,N,ML,MU,IWM(21),IER)
  240 CONTINUE
      RETURN
C     ----------------------- END OF SUBROUTINE DPJAC
C     -----------------------
      END
      SUBROUTINE DSCAL(N,DA,DX,INCX)
C***BEGIN PROLOGUE  DSCAL
C***DATE WRITTEN   791001   (YYMMDD)
C***REVISION DATE  820801   (YYMMDD)
C***CATEGORY NO.  D1A6
C***KEYWORDS  BLAS,LINEAR ALGEBRA,VECTOR,SCALE
C***AUTHOR  LAWSON, C. L., (JPL)
C           HANSON, R. J., (SNLA)
C           KINCAID, D. R., (U. OF TEXAS)
C           KROGH, F. T., (JPL)
C***PURPOSE  D.P. VECTOR SCALE X = A*X
C***DESCRIPTION
C                B L A S  SUBPROGRAM
C    DESCRIPTION OF PARAMETERS
C
C     --INPUT--
C        N  NUMBER OF ELEMENTS IN INPUT VECTOR(S)
C       DA  DOUBLE PRECISION SCALE FACTOR
C       DX  DOUBLE PRECISION VECTOR WITH N ELEMENTS
C     INCX  STORAGE SPACING BETWEEN ELEMENTS OF DX
C
C     --OUTPUT--
C       DX  DOUBLE PRECISION RESULT (UNCHANGED IF N.LE.0)
C
C     REPLACE DOUBLE PRECISION DX BY DOUBLE PRECISION DA*DX.
C     FOR I = 0 TO N-1, REPLACE DX(1+I*INCX) WITH  DA * DX(1+I*INCX)
C***REFERENCES  LAWSON C.L., HANSON R.J., KINCAID D.R., KROGH F.T.,
C                 *BASIC LINEAR ALGEBRA SUBPROGRAMS FOR FORTRAN USAGE*,
C                 ALGORITHM NO. 539, TRANSACTIONS ON MATHEMATICAL
C                 SOFTWARE, VOLUME 5, NUMBER 3, SEPTEMBER 1979, 308-323
C***ROUTINES CALLED  (NONE)
C***END PROLOGUE  DSCAL
C
      DOUBLE PRECISION DA,DX(1)
C***FIRST EXECUTABLE STATEMENT  DSCAL
      IF(N.LE.0)RETURN
      IF(INCX.EQ.1)GOTO 20
C
C        CODE FOR INCREMENTS NOT EQUAL TO 1.
C
      NS = N*INCX
          DO 10 I = 1,NS,INCX
          DX(I) = DA*DX(I)
   10     CONTINUE
      RETURN
C
C        CODE FOR INCREMENTS EQUAL TO 1.
C
C
C        CLEAN-UP LOOP SO REMAINING VECTOR LENGTH IS A MULTIPLE OF 5.
C
   20 M = MOD(N,5)
      IF( M .EQ. 0 ) GO TO 40
      DO 30 I = 1,M
        DX(I) = DA*DX(I)
   30 CONTINUE
      IF( N .LT. 5 ) RETURN
   40 MP1 = M + 1
      DO 50 I = MP1,N,5
        DX(I) = DA*DX(I)
        DX(I + 1) = DA*DX(I + 1)
        DX(I + 2) = DA*DX(I + 2)
        DX(I + 3) = DA*DX(I + 3)
        DX(I + 4) = DA*DX(I + 4)
   50 CONTINUE
      RETURN
      END
      SUBROUTINE DSLVS(WM,IWM,X,TEM)
C***BEGIN PROLOGUE  DSLVS
C***REFER TO  DDEBDF
C   DSLVS SOLVES THE LINEAR SYSTEM IN THE ITERATION SCHEME FOR THE
C   INTEGRATOR PACKAGE DDEBDF.
C***ROUTINES CALLED  DGESL,DGBSL
C***COMMON BLOCKS    DEBDF1
C***END PROLOGUE  DSLVS
C
      INTEGER I, IER, IOWND, IOWNS, IWM, JSTART, KFLAG, L, MAXORD,
     *      MEBAND, METH, MITER, ML, MU, N, NFE, NJE, NQ, NQU, NST
      DOUBLE PRECISION DABS, DI, EL0, H, HL0, HMIN, HMXI, HU, PHL0,
     *      R, ROWND, ROWNS, TEM, TN, UROUND, WM, X
      DIMENSION WM(3),IWM(21),X(1),TEM(1)
      COMMON /DEBDF1/ ROWND,ROWNS(210),EL0,H,HMIN,HMXI,HU,TN,UROUND,
     *                IOWND(14),IOWNS(6),IER,JSTART,KFLAG,L,METH,MITER,
     *                MAXORD,N,NQ,NST,NFE,NJE,NQU
C     ------------------------------------------------------------------
C      THIS ROUTINE MANAGES THE SOLUTION OF THE LINEAR SYSTEM ARISING
C      FROM A CHORD ITERATION.  IT IS CALLED BY DSTOD  IF MITER .NE. 0.
C      IF MITER IS 1 OR 2, IT CALLS DGESL TO ACCOMPLISH THIS.
C      IF MITER = 3 IT UPDATES THE COEFFICIENT H*EL0 IN THE DIAGONAL
C      MATRIX, AND THEN COMPUTES THE SOLUTION.
C      IF MITER IS 4 OR 5, IT CALLS DGBSL.
C      COMMUNICATION WITH DSLVS USES THE FOLLOWING VARIABLES..
C      WM  = DOUBLE PRECISION WORK SPACE CONTAINING THE INVERSE DIAGONAL
C      MATRIX IF MITER
C            IS 3 AND THE LU DECOMPOSITION OF THE MATRIX OTHERWISE.
C            STORAGE OF MATRIX ELEMENTS STARTS AT WM(3).
C            WM ALSO CONTAINS THE FOLLOWING MATRIX-RELATED DATA..
C            WM(1) = SQRT(UROUND) (NOT USED HERE),
C            WM(2) = HL0, THE PREVIOUS VALUE OF H*EL0, USED IF MITER =
C            3.
C      IWM = INTEGER WORK SPACE CONTAINING PIVOT INFORMATION, STARTING
C            AT IWM(21), IF MITER IS 1, 2, 4, OR 5.  IWM ALSO CONTAINS
C            THE BAND PARAMETERS ML = IWM(1) AND MU = IWM(2) IF MITER IS
C            4 OR 5.
C      X   = THE RIGHT-HAND SIDE VECTOR ON INPUT, AND THE SOLUTION
C            VECTOR ON OUTPUT, OF LENGTH N.
C      TEM = VECTOR OF WORK SPACE OF LENGTH N, NOT USED IN THIS VERSION.
C      IER = OUTPUT FLAG (IN COMMON).  IER = 0 IF NO TROUBLE OCCURRED.
C            IER = -1 IF A SINGULAR MATRIX AROSE WITH MITER = 3.
C      THIS ROUTINE ALSO USES THE COMMON VARIABLES EL0, H, MITER, AND N.
C-----------------------------------------------------------------------
C***FIRST EXECUTABLE STATEMENT  DSLVS
C     BEGIN BLOCK PERMITTING ...EXITS TO 80
C        BEGIN BLOCK PERMITTING ...EXITS TO 60
            IER = 0
            GO TO (10,10,20,70,70), MITER
   10       CONTINUE
            CALL DGESL(WM(3),N,N,IWM(21),X,0)
C     ......EXIT
            GO TO 80
C
   20       CONTINUE
            PHL0 = WM(2)
            HL0 = H*EL0
            WM(2) = HL0
            IF (HL0 .EQ. PHL0) GO TO 40
               R = HL0/PHL0
               DO 30 I = 1, N
                  DI = 1.0D0 - R*(1.0D0 - 1.0D0/WM(I+2))
C        .........EXIT
                  IF (DABS(DI) .EQ. 0.0D0) GO TO 60
                  WM(I+2) = 1.0D0/DI
   30          CONTINUE
   40       CONTINUE
            DO 50 I = 1, N
               X(I) = WM(I+2)*X(I)
   50       CONTINUE
C     ......EXIT
            GO TO 80
   60    CONTINUE
         IER = -1
C     ...EXIT
         GO TO 80
C
   70    CONTINUE
         ML = IWM(1)
         MU = IWM(2)
         MEBAND = 2*ML + MU + 1
         CALL DGBSL(WM(3),MEBAND,N,ML,MU,IWM(21),X,0)
   80 CONTINUE
      RETURN
C     ----------------------- END OF SUBROUTINE DSLVS
C     -----------------------
      END
      SUBROUTINE DSTOD(NEQ,Y,YH,NYH,YH1,EWT,SAVF,ACOR,WM,IWM,DF,DJAC,
     *                 RPAR,IPAR)
C***BEGIN PROLOGUE  DSTOD
C***REFER TO  DDEBDF
C   DSTOD INTEGRATES A SYSTEM OF FIRST ORDER ODES OVER ONE STEP IN THE
C   INTEGRATOR PACKAGE DDEBDF.
C-----------------------------------------------------------------------
C DSTOD  PERFORMS ONE STEP OF THE INTEGRATION OF AN INITIAL VALUE
C PROBLEM FOR A SYSTEM OF ORDINARY DIFFERENTIAL EQUATIONS.
C NOTE.. DSTOD  IS INDEPENDENT OF THE VALUE OF THE ITERATION METHOD
C INDICATOR MITER, WHEN THIS IS .NE. 0, AND HENCE IS INDEPENDENT
C OF THE TYPE OF CHORD METHOD USED, OR THE JACOBIAN STRUCTURE.
C COMMUNICATION WITH DSTOD  IS DONE WITH THE FOLLOWING VARIABLES..
C
C Y      = AN ARRAY OF LENGTH .GE. N USED AS THE Y ARGUMENT IN
C          ALL CALLS TO DF AND DJAC.
C NEQ    = INTEGER ARRAY CONTAINING PROBLEM SIZE IN NEQ(1), AND
C          PASSED AS THE NEQ ARGUMENT IN ALL CALLS TO DF AND DJAC.
C YH     = AN NYH BY LMAX ARRAY CONTAINING THE DEPENDENT VARIABLES
C          AND THEIR APPROXIMATE SCALED DERIVATIVES, WHERE
C          LMAX = MAXORD + 1.  YH(I,J+1) CONTAINS THE APPROXIMATE
C          J-TH DERIVATIVE OF Y(I), SCALED BY H**J/FACTORIAL(J)
C          (J = 0,1,...,NQ).  ON ENTRY FOR THE FIRST STEP, THE FIRST
C          TWO COLUMNS OF YH MUST BE SET FROM THE INITIAL VALUES.
C NYH    = A CONSTANT INTEGER .GE. N, THE FIRST DIMENSION OF YH.
C YH1    = A ONE-DIMENSIONAL ARRAY OCCUPYING THE SAME SPACE AS YH.
C EWT    = AN ARRAY OF N ELEMENTS WITH WHICH THE ESTIMATED LOCAL
C          ERRORS IN YH ARE COMPARED.
C SAVF   = AN ARRAY OF WORKING STORAGE, OF LENGTH N.
C ACOR   = A WORK ARRAY OF LENGTH N, USED FOR THE ACCUMULATED
C          CORRECTIONS.  ON A SUCCESSFUL RETURN, ACOR(I) CONTAINS
C          THE ESTIMATED ONE-STEP LOCAL ERROR IN Y(I).
C WM,IWM = DOUBLE PRECISION AND INTEGER WORK ARRAYS ASSOCIATED WITH
C          MATRIX OPERATIONS IN CHORD ITERATION (MITER .NE. 0).
C DPJAC   = NAME OF ROUTINE TO EVALUATE AND PREPROCESS JACOBIAN MATRIX
C          IF A CHORD METHOD IS BEING USED.
C DSLVS   = NAME OF ROUTINE TO SOLVE LINEAR SYSTEM IN CHORD ITERATION.
C H      = THE STEP SIZE TO BE ATTEMPTED ON THE NEXT STEP.
C          H IS ALTERED BY THE ERROR CONTROL ALGORITHM DURING THE
C          PROBLEM.  H CAN BE EITHER POSITIVE OR NEGATIVE, BUT ITS
C          SIGN MUST REMAIN CONSTANT THROUGHOUT THE PROBLEM.
C HMIN   = THE MINIMUM ABSOLUTE VALUE OF THE STEP SIZE H TO BE USED.
C HMXI   = INVERSE OF THE MAXIMUM ABSOLUTE VALUE OF H TO BE USED.
C          HMXI = 0.0 IS ALLOWED AND CORRESPONDS TO AN INFINITE HMAX.
C          HMIN AND HMXI MAY BE CHANGED AT ANY TIME, BUT WILL NOT
C          TAKE EFFECT UNTIL THE NEXT CHANGE OF H IS CONSIDERED.
C TN     = THE INDEPENDENT VARIABLE. TN IS UPDATED ON EACH STEP TAKEN.
C JSTART = AN INTEGER USED FOR INPUT ONLY, WITH THE FOLLOWING
C          VALUES AND MEANINGS..
C               0  PERFORM THE FIRST STEP.
C           .GT.0  TAKE A NEW STEP CONTINUING FROM THE LAST.
C              -1  TAKE THE NEXT STEP WITH A NEW VALUE OF H, MAXORD,
C                    N, METH, MITER, AND/OR MATRIX PARAMETERS.
C              -2  TAKE THE NEXT STEP WITH A NEW VALUE OF H,
C                    BUT WITH OTHER INPUTS UNCHANGED.
C          ON RETURN, JSTART IS SET TO 1 TO FACILITATE CONTINUATION.
C KFLAG  = A COMPLETION CODE WITH THE FOLLOWING MEANINGS..
C               0  THE STEP WAS SUCCESFUL.
C              -1  THE REQUESTED ERROR COULD NOT BE ACHIEVED.
C              -2  CORRECTOR CONVERGENCE COULD NOT BE ACHIEVED.
C          A RETURN WITH KFLAG = -1 OR -2 MEANS EITHER
C          DABS(H) = HMIN OR 10 CONSECUTIVE FAILURES OCCURRED.
C          ON A RETURN WITH KFLAG NEGATIVE, THE VALUES OF TN AND
C          THE YH ARRAY ARE AS OF THE BEGINNING OF THE LAST
C          STEP, AND H IS THE LAST STEP SIZE ATTEMPTED.
C MAXORD = THE MAXIMUM ORDER OF INTEGRATION METHOD TO BE ALLOWED.
C METH/MITER = THE METHOD FLAGS.  SEE DESCRIPTION IN DRIVER.
C N      = THE NUMBER OF FIRST-ORDER DIFFERENTIAL EQUATIONS.
C-----------------------------------------------------------------------
C***ROUTINES CALLED  DCFOD,DSLVS,DPJAC,DVNRMS
C***COMMON BLOCKS    DEBDF1
C***END PROLOGUE  DSTOD
C
      INTEGER I, I1, IALTH, IER, IOD, IOWND, IPAR, IPUP, IREDO, IRET,
     *      IWM, J, JB, JSTART, KFLAG, KSTEPS, L, LMAX, M, MAXORD,
     *      MEO, METH, MITER, N, NCF, NEQ, NEWQ, NFE, NJE, NQ, NQNYH,
     *      NQU, NST, NSTEPJ, NYH
      DOUBLE PRECISION ACOR, CONIT, CRATE, DABS, DBLE, DCON, DDN,
     *      DEL, DELP, DMAX1, DMIN1, DSM, DUP, DVNRMS, EL, EL0, ELCO,
     *      EWT, EXDN, EXSM, EXUP, H, HMIN, HMXI, HOLD, HU, R, RC,
     *      RH, RHDN, RHSM, RHUP, RMAX, ROWND, RPAR, SAVF, TESCO,
     *      TN, TOLD, UROUND, WM, Y, YH, YH1
      EXTERNAL DF,DJAC
C
      DIMENSION Y(1),YH(NYH,2),YH1(1),EWT(1),SAVF(1),ACOR(1),WM(1),
     *          IWM(1),RPAR(1),IPAR(1)
      COMMON /DEBDF1/ ROWND,CONIT,CRATE,EL(13),ELCO(13,12),HOLD,RC,RMAX,
     *                TESCO(3,12),EL0,H,HMIN,HMXI,HU,TN,UROUND,IOWND(7),
     *                KSTEPS,IOD(6),IALTH,IPUP,LMAX,MEO,NQNYH,NSTEPJ,
     *                IER,JSTART,KFLAG,L,METH,MITER,MAXORD,N,NQ,NST,NFE,
     *                NJE,NQU
C
C
C***FIRST EXECUTABLE STATEMENT  DSTOD
C     BEGIN BLOCK PERMITTING ...EXITS TO 690
C        BEGIN BLOCK PERMITTING ...EXITS TO 60
            KFLAG = 0
            TOLD = TN
            NCF = 0
            IF (JSTART .GT. 0) GO TO 160
            IF (JSTART .EQ. -1) GO TO 10
               IF (JSTART .EQ. -2) GO TO 90
C              ---------------------------------------------------------
C               ON THE FIRST CALL, THE ORDER IS SET TO 1, AND OTHER
C               VARIABLES ARE INITIALIZED.  RMAX IS THE MAXIMUM RATIO BY
C               WHICH H CAN BE INCREASED IN A SINGLE STEP.  IT IS
C               INITIALLY 1.E4 TO COMPENSATE FOR THE SMALL INITIAL H,
C               BUT THEN IS NORMALLY EQUAL TO 10.  IF A FAILURE OCCURS
C               (IN CORRECTOR CONVERGENCE OR ERROR TEST), RMAX IS SET AT
C               2 FOR THE NEXT INCREASE.
C              ---------------------------------------------------------
               LMAX = MAXORD + 1
               NQ = 1
               L = 2
               IALTH = 2
               RMAX = 10000.0D0
               RC = 0.0D0
               EL0 = 1.0D0
               CRATE = 0.7D0
               DELP = 0.0D0
               HOLD = H
               MEO = METH
               NSTEPJ = 0
               IRET = 3
            GO TO 50
   10       CONTINUE
C              BEGIN BLOCK PERMITTING ...EXITS TO 30
C                 ------------------------------------------------------
C                  THE FOLLOWING BLOCK HANDLES PRELIMINARIES NEEDED WHEN
C                  JSTART = -1.  IPUP IS SET TO MITER TO FORCE A MATRIX
C                  UPDATE.  IF AN ORDER INCREASE IS ABOUT TO BE
C                  CONSIDERED (IALTH = 1), IALTH IS RESET TO 2 TO
C                  POSTPONE CONSIDERATION ONE MORE STEP.  IF THE CALLER
C                  HAS CHANGED METH, DCFOD  IS CALLED TO RESET THE
C                  COEFFICIENTS OF THE METHOD.  IF THE CALLER HAS
C                  CHANGED MAXORD TO A VALUE LESS THAN THE CURRENT
C                  ORDER NQ, NQ IS REDUCED TO MAXORD, AND A NEW H CHOSEN
C                  ACCORDINGLY.  IF H IS TO BE CHANGED, YH MUST BE
C                  RESCALED.  IF H OR METH IS BEING CHANGED, IALTH IS
C                  RESET TO L = NQ + 1 TO PREVENT FURTHER CHANGES IN H
C                  FOR THAT MANY STEPS.
C                 ------------------------------------------------------
                  IPUP = MITER
                  LMAX = MAXORD + 1
                  IF (IALTH .EQ. 1) IALTH = 2
                  IF (METH .EQ. MEO) GO TO 20
                     CALL DCFOD(METH,ELCO,TESCO)
                     MEO = METH
C              ......EXIT
                     IF (NQ .GT. MAXORD) GO TO 30
                     IALTH = L
                     IRET = 1
C        ............EXIT
                     GO TO 60
   20             CONTINUE
                  IF (NQ .LE. MAXORD) GO TO 90
   30          CONTINUE
               NQ = MAXORD
               L = LMAX
               DO 40 I = 1, L
                  EL(I) = ELCO(I,NQ)
   40          CONTINUE
               NQNYH = NQ*NYH
               RC = RC*EL(1)/EL0
               EL0 = EL(1)
               CONIT = 0.5D0/DBLE(FLOAT(NQ+2))
               DDN = DVNRMS(N,SAVF,EWT)/TESCO(1,L)
               EXDN = 1.0D0/DBLE(FLOAT(L))
               RHDN = 1.0D0/(1.3D0*DDN**EXDN + 0.0000013D0)
               RH = DMIN1(RHDN,1.0D0)
               IREDO = 3
               IF (H .EQ. HOLD) GO TO 660
               RH = DMIN1(RH,DABS(H/HOLD))
               H = HOLD
               GO TO 100
   50       CONTINUE
C           ------------------------------------------------------------
C            DCFOD  IS CALLED TO GET ALL THE INTEGRATION COEFFICIENTS
C            FOR THE CURRENT METH.  THEN THE EL VECTOR AND RELATED
C            CONSTANTS ARE RESET WHENEVER THE ORDER NQ IS CHANGED, OR AT
C            THE START OF THE PROBLEM.
C           ------------------------------------------------------------
            CALL DCFOD(METH,ELCO,TESCO)
   60    CONTINUE
   70    CONTINUE
C           BEGIN BLOCK PERMITTING ...EXITS TO 680
               DO 80 I = 1, L
                  EL(I) = ELCO(I,NQ)
   80          CONTINUE
               NQNYH = NQ*NYH
               RC = RC*EL(1)/EL0
               EL0 = EL(1)
               CONIT = 0.5D0/DBLE(FLOAT(NQ+2))
               GO TO (90,660,160), IRET
C              ---------------------------------------------------------
C               IF H IS BEING CHANGED, THE H RATIO RH IS CHECKED AGAINST
C               RMAX, HMIN, AND HMXI, AND THE YH ARRAY RESCALED.  IALTH
C               IS SET TO L = NQ + 1 TO PREVENT A CHANGE OF H FOR THAT
C               MANY STEPS, UNLESS FORCED BY A CONVERGENCE OR ERROR TEST
C               FAILURE.
C              ---------------------------------------------------------
   90          CONTINUE
               IF (H .EQ. HOLD) GO TO 160
               RH = H/HOLD
               H = HOLD
               IREDO = 3
  100          CONTINUE
  110          CONTINUE
                  RH = DMIN1(RH,RMAX)
                  RH = RH/DMAX1(1.0D0,DABS(H)*HMXI*RH)
                  R = 1.0D0
                  DO 130 J = 2, L
                     R = R*RH
                     DO 120 I = 1, N
                        YH(I,J) = YH(I,J)*R
  120                CONTINUE
  130             CONTINUE
                  H = H*RH
                  RC = RC*RH
                  IALTH = L
                  IF (IREDO .NE. 0) GO TO 150
                     RMAX = 10.0D0
                     R = 1.0D0/TESCO(2,NQU)
                     DO 140 I = 1, N
                        ACOR(I) = ACOR(I)*R
  140                CONTINUE
C     ...............EXIT
                     GO TO 690
  150             CONTINUE
C                 ------------------------------------------------------
C                  THIS SECTION COMPUTES THE PREDICTED VALUES BY
C                  EFFECTIVELY MULTIPLYING THE YH ARRAY BY THE PASCAL
C                  TRIANGLE MATRIX.  RC IS THE RATIO OF NEW TO OLD
C                  VALUES OF THE COEFFICIENT  H*EL(1).  WHEN RC DIFFERS
C                  FROM 1 BY MORE THAN 30 PERCENT, IPUP IS SET TO MITER
C                  TO FORCE DPJAC TO BE CALLED, IF A JACOBIAN IS
C                  INVOLVED.  IN ANY CASE, DPJAC IS CALLED AT LEAST
C                  EVERY 20-TH STEP.
C                 ------------------------------------------------------
  160             CONTINUE
  170             CONTINUE
C                    BEGIN BLOCK PERMITTING ...EXITS TO 610
C                       BEGIN BLOCK PERMITTING ...EXITS TO 490
                           IF (DABS(RC-1.0D0) .GT. 0.3D0) IPUP = MITER
                           IF (NST .GE. NSTEPJ + 20) IPUP = MITER
                           TN = TN + H
                           I1 = NQNYH + 1
                           DO 190 JB = 1, NQ
                              I1 = I1 - NYH
                              DO 180 I = I1, NQNYH
                                 YH1(I) = YH1(I) + YH1(I+NYH)
  180                         CONTINUE
  190                      CONTINUE
                           KSTEPS = KSTEPS + 1
C                          ---------------------------------------------
C                           UP TO 3 CORRECTOR ITERATIONS ARE TAKEN.  A
C                           CONVERGENCE TEST IS MADE ON THE R.M.S. NORM
C                           OF EACH CORRECTION, WEIGHTED BY THE ERROR
C                           WEIGHT VECTOR EWT.  THE SUM OF THE
C                           CORRECTIONS IS ACCUMULATED IN THE VECTOR
C                           ACOR(I).  THE YH ARRAY IS NOT ALTERED IN THE
C                           CORRECTOR LOOP.
C                          ---------------------------------------------
  200                      CONTINUE
                              M = 0
                              DO 210 I = 1, N
                                 Y(I) = YH(I,1)
  210                         CONTINUE
                              CALL DF(TN,Y,SAVF,RPAR,IPAR)
                              NFE = NFE + 1
                              IF (IPUP .LE. 0) GO TO 220
C                                ---------------------------------------
C                                 IF INDICATED, THE MATRIX P = I -
C                                 H*EL(1)*J IS REEVALUATED AND
C                                 PREPROCESSED BEFORE STARTING THE
C                                 CORRECTOR ITERATION.  IPUP IS SET TO 0
C                                 AS AN INDICATOR THAT THIS HAS BEEN
C                                 DONE.
C                                ---------------------------------------
                                 IPUP = 0
                                 RC = 1.0D0
                                 NSTEPJ = NST
                                 CRATE = 0.7D0
                                 CALL DPJAC(NEQ,Y,YH,NYH,EWT,ACOR,SAVF,
     *                                      WM,IWM,DF,DJAC,RPAR,IPAR)
C                          ......EXIT
                                 IF (IER .NE. 0) GO TO 440
  220                         CONTINUE
                              DO 230 I = 1, N
                                 ACOR(I) = 0.0D0
  230                         CONTINUE
  240                         CONTINUE
                                 IF (MITER .NE. 0) GO TO 270
C                                   ------------------------------------
C                                    IN THE CASE OF FUNCTIONAL
C                                    ITERATION, UPDATE Y DIRECTLY FROM
C                                    THE RESULT OF THE LAST FUNCTION
C                                    EVALUATION.
C                                   ------------------------------------
                                    DO 250 I = 1, N
                                       SAVF(I) = H*SAVF(I) - YH(I,2)
                                       Y(I) = SAVF(I) - ACOR(I)
  250                               CONTINUE
                                    DEL = DVNRMS(N,Y,EWT)
                                    DO 260 I = 1, N
                                       Y(I) = YH(I,1) + EL(1)*SAVF(I)
                                       ACOR(I) = SAVF(I)
  260                               CONTINUE
                                 GO TO 300
  270                            CONTINUE
C                                   ------------------------------------
C                                    IN THE CASE OF THE CHORD METHOD,
C                                    COMPUTE THE CORRECTOR ERROR, AND
C                                    SOLVE THE LINEAR SYSTEM WITH THAT
C                                    AS RIGHT-HAND SIDE AND P AS
C                                    COEFFICIENT MATRIX.
C                                   ------------------------------------
                                    DO 280 I = 1, N
                                       Y(I) = H*SAVF(I)
     *                                        - (YH(I,2) + ACOR(I))
  280                               CONTINUE
                                    CALL DSLVS(WM,IWM,Y,SAVF)
C                             ......EXIT
                                    IF (IER .NE. 0) GO TO 430
                                    DEL = DVNRMS(N,Y,EWT)
                                    DO 290 I = 1, N
                                       ACOR(I) = ACOR(I) + Y(I)
                                       Y(I) = YH(I,1) + EL(1)*ACOR(I)
  290                               CONTINUE
  300                            CONTINUE
C                                ---------------------------------------
C                                 TEST FOR CONVERGENCE.  IF M.GT.0, AN
C                                 ESTIMATE OF THE CONVERGENCE RATE
C                                 CONSTANT IS STORED IN CRATE, AND THIS
C                                 IS USED IN THE TEST.
C                                ---------------------------------------
                                 IF (M .NE. 0)
     *                              CRATE = DMAX1(0.2D0*CRATE,DEL/DELP)
                                 DCON = DEL*DMIN1(1.0D0,1.5D0*CRATE)
     *                                  /(TESCO(2,NQ)*CONIT)
                                 IF (DCON .GT. 1.0D0) GO TO 420
C                                   ------------------------------------
C                                    THE CORRECTOR HAS CONVERGED.  IPUP
C                                    IS SET TO -1 IF MITER .NE. 0, TO
C                                    SIGNAL THAT THE JACOBIAN INVOLVED
C                                    MAY NEED UPDATING LATER.  THE LOCAL
C                                    ERROR TEST IS MADE AND CONTROL
C                                    PASSES TO STATEMENT 500 IF IT
C                                    FAILS.
C                                   ------------------------------------
                                    IF (MITER .NE. 0) IPUP = -1
                                    IF (M .EQ. 0) DSM = DEL/TESCO(2,NQ)
                                    IF (M .GT. 0)
     *                                 DSM = DVNRMS(N,ACOR,EWT)
     *                                       /TESCO(2,NQ)
                                    IF (DSM .GT. 1.0D0) GO TO 380
C                                      BEGIN BLOCK
C                                      PERMITTING ...EXITS TO 360
C                                         ------------------------------
C                                          AFTER A SUCCESSFUL STEP,
C                                          UPDATE THE YH ARRAY.
C                                          CONSIDER CHANGING H IF IALTH
C                                          = 1.  OTHERWISE DECREASE
C                                          IALTH BY 1.  IF IALTH IS THEN
C                                          1 AND NQ .LT. MAXORD, THEN
C                                          ACOR IS SAVED FOR USE IN A
C                                          POSSIBLE ORDER INCREASE ON
C                                          THE NEXT STEP.  IF A CHANGE
C                                          IN H IS CONSIDERED, AN
C                                          INCREASE OR DECREASE IN ORDER
C                                          BY ONE IS CONSIDERED ALSO.  A
C                                          CHANGE IN H IS MADE ONLY IF
C                                          IT IS BY A FACTOR OF AT LEAST
C                                          1.1.  IF NOT, IALTH IS SET TO
C                                          3 TO PREVENT TESTING FOR THAT
C                                          MANY STEPS.
C                                         ------------------------------
                                          KFLAG = 0
                                          IREDO = 0
                                          NST = NST + 1
                                          HU = H
                                          NQU = NQ
                                          DO 320 J = 1, L
                                             DO 310 I = 1, N
                                                YH(I,J) = YH(I,J)
     *                                                    + EL(J)
     *                                                      *ACOR(I)
  310                                        CONTINUE
  320                                     CONTINUE
                                          IALTH = IALTH - 1
                                          IF (IALTH .NE. 0) GO TO 340
C                                            ---------------------------
C                                             REGARDLESS OF THE SUCCESS
C                                             OR FAILURE OF THE STEP,
C                                             FACTORS RHDN, RHSM, AND
C                                             RHUP ARE COMPUTED, BY
C                                             WHICH H COULD BE
C                                             MULTIPLIED AT ORDER NQ -
C                                             1, ORDER NQ, OR ORDER NQ +
C                                             1, RESPECTIVELY.  IN THE
C                                             CASE OF FAILURE, RHUP =
C                                             0.0 TO AVOID AN ORDER
C                                             INCREASE.  THE LARGEST OF
C                                             THESE IS DETERMINED AND
C                                             THE NEW ORDER CHOSEN
C                                             ACCORDINGLY.  IF THE ORDER
C                                             IS TO BE INCREASED, WE
C                                             COMPUTE ONE ADDITIONAL
C                                             SCALED DERIVATIVE.
C                                            ---------------------------
                                             RHUP = 0.0D0
C                       .....................EXIT
                                             IF (L .EQ. LMAX) GO TO 490
                                             DO 330 I = 1, N
                                                SAVF(I) = ACOR(I)
     *                                                    - YH(I,LMAX)
  330                                        CONTINUE
                                             DUP = DVNRMS(N,SAVF,EWT)
     *                                             /TESCO(3,NQ)
                                             EXUP = 1.0D0
     *                                              /DBLE(FLOAT(L+1))
                                             RHUP = 1.0D0
     *                                              /(1.4D0*DUP**EXUP
     *                                                + 0.0000014D0)
C                       .....................EXIT
                                             GO TO 490
  340                                     CONTINUE
C                                      ...EXIT
                                          IF (IALTH .GT. 1) GO TO 360
C                                      ...EXIT
                                          IF (L .EQ. LMAX) GO TO 360
                                          DO 350 I = 1, N
                                             YH(I,LMAX) = ACOR(I)
  350                                     CONTINUE
  360                                  CONTINUE
                                       R = 1.0D0/TESCO(2,NQU)
                                       DO 370 I = 1, N
                                          ACOR(I) = ACOR(I)*R
  370                                  CONTINUE
C     .................................EXIT
                                       GO TO 690
  380                               CONTINUE
C                                   ------------------------------------
C                                    THE ERROR TEST FAILED.  KFLAG KEEPS
C                                    TRACK OF MULTIPLE FAILURES.
C                                    RESTORE TN AND THE YH ARRAY TO
C                                    THEIR PREVIOUS VALUES, AND PREPARE
C                                    TO TRY THE STEP AGAIN.  COMPUTE THE
C                                    OPTIMUM STEP SIZE FOR THIS OR ONE
C                                    LOWER ORDER.  AFTER 2 OR MORE
C                                    FAILURES, H IS FORCED TO DECREASE
C                                    BY A FACTOR OF 0.2 OR LESS.
C                                   ------------------------------------
                                    KFLAG = KFLAG - 1
                                    TN = TOLD
                                    I1 = NQNYH + 1
                                    DO 400 JB = 1, NQ
                                       I1 = I1 - NYH
                                       DO 390 I = I1, NQNYH
                                          YH1(I) = YH1(I) - YH1(I+NYH)
  390                                  CONTINUE
  400                               CONTINUE
                                    RMAX = 2.0D0
                                    IF (DABS(H) .GT. HMIN*1.00001D0)
     *                                 GO TO 410
C                                      ---------------------------------
C                                       ALL RETURNS ARE MADE THROUGH
C                                       THIS SECTION.  H IS SAVED IN
C                                       HOLD TO ALLOW THE CALLER TO
C                                       CHANGE H ON THE NEXT STEP.
C                                      ---------------------------------
                                       KFLAG = -1
C     .................................EXIT
                                       GO TO 690
  410                               CONTINUE
C                    ...............EXIT
                                    IF (KFLAG .LE. -3) GO TO 610
                                    IREDO = 2
                                    RHUP = 0.0D0
C                       ............EXIT
                                    GO TO 490
  420                            CONTINUE
                                 M = M + 1
C                             ...EXIT
                                 IF (M .EQ. 3) GO TO 430
C                             ...EXIT
                                 IF (M .GE. 2 .AND. DEL .GT. 2.0D0*DELP)
     *                              GO TO 430
                                 DELP = DEL
                                 CALL DF(TN,Y,SAVF,RPAR,IPAR)
                                 NFE = NFE + 1
                              GO TO 240
  430                         CONTINUE
C                             ------------------------------------------
C                              THE CORRECTOR ITERATION FAILED TO
C                              CONVERGE IN 3 TRIES.  IF MITER .NE. 0 AND
C                              THE JACOBIAN IS OUT OF DATE, DPJAC IS
C                              CALLED FOR THE NEXT TRY.  OTHERWISE THE
C                              YH ARRAY IS RETRACTED TO ITS VALUES
C                              BEFORE PREDICTION, AND H IS REDUCED, IF
C                              POSSIBLE.  IF H CANNOT BE REDUCED OR 10
C                              FAILURES HAVE OCCURRED, EXIT WITH KFLAG =
C                              -2.
C                             ------------------------------------------
C                          ...EXIT
                              IF (IPUP .EQ. 0) GO TO 440
                              IPUP = MITER
                           GO TO 200
  440                      CONTINUE
                           TN = TOLD
                           NCF = NCF + 1
                           RMAX = 2.0D0
                           I1 = NQNYH + 1
                           DO 460 JB = 1, NQ
                              I1 = I1 - NYH
                              DO 450 I = I1, NQNYH
                                 YH1(I) = YH1(I) - YH1(I+NYH)
  450                         CONTINUE
  460                      CONTINUE
                           IF (DABS(H) .GT. HMIN*1.00001D0) GO TO 470
                              KFLAG = -2
C     ........................EXIT
                              GO TO 690
  470                      CONTINUE
                           IF (NCF .NE. 10) GO TO 480
                              KFLAG = -2
C     ........................EXIT
                              GO TO 690
  480                      CONTINUE
                           RH = 0.25D0
                           IPUP = MITER
                           IREDO = 1
C                 .........EXIT
                           GO TO 650
  490                   CONTINUE
                        EXSM = 1.0D0/DBLE(FLOAT(L))
                        RHSM = 1.0D0/(1.2D0*DSM**EXSM + 0.0000012D0)
                        RHDN = 0.0D0
                        IF (NQ .EQ. 1) GO TO 500
                           DDN = DVNRMS(N,YH(1,L),EWT)/TESCO(1,NQ)
                           EXDN = 1.0D0/DBLE(FLOAT(NQ))
                           RHDN = 1.0D0/(1.3D0*DDN**EXDN + 0.0000013D0)
  500                   CONTINUE
                        IF (RHSM .GE. RHUP) GO TO 550
                           IF (RHUP .LE. RHDN) GO TO 540
                              NEWQ = L
                              RH = RHUP
                              IF (RH .GE. 1.1D0) GO TO 520
                                 IALTH = 3
                                 R = 1.0D0/TESCO(2,NQU)
                                 DO 510 I = 1, N
                                    ACOR(I) = ACOR(I)*R
  510                            CONTINUE
C     ...........................EXIT
                                 GO TO 690
  520                         CONTINUE
                              R = EL(L)/DBLE(FLOAT(L))
                              DO 530 I = 1, N
                                 YH(I,NEWQ+1) = ACOR(I)*R
  530                         CONTINUE
                              NQ = NEWQ
                              L = NQ + 1
                              IRET = 2
C           ..................EXIT
                              GO TO 680
  540                      CONTINUE
                        GO TO 580
  550                   CONTINUE
                        IF (RHSM .LT. RHDN) GO TO 580
                           NEWQ = NQ
                           RH = RHSM
                           IF (KFLAG .EQ. 0 .AND. RH .LT. 1.1D0)
     *                        GO TO 560
                              IF (KFLAG .LE. -2) RH = DMIN1(RH,0.2D0)
C                             ------------------------------------------
C                              IF THERE IS A CHANGE OF ORDER, RESET NQ,
C                              L, AND THE COEFFICIENTS.  IN ANY CASE H
C                              IS RESET ACCORDING TO RH AND THE YH ARRAY
C                              IS RESCALED.  THEN EXIT FROM 680 IF THE
C                              STEP WAS OK, OR REDO THE STEP OTHERWISE.
C                             ------------------------------------------
C                 ............EXIT
                              IF (NEWQ .EQ. NQ) GO TO 650
                              NQ = NEWQ
                              L = NQ + 1
                              IRET = 2
C           ..................EXIT
                              GO TO 680
  560                      CONTINUE
                           IALTH = 3
                           R = 1.0D0/TESCO(2,NQU)
                           DO 570 I = 1, N
                              ACOR(I) = ACOR(I)*R
  570                      CONTINUE
C     .....................EXIT
                           GO TO 690
  580                   CONTINUE
                        NEWQ = NQ - 1
                        RH = RHDN
                        IF (KFLAG .LT. 0 .AND. RH .GT. 1.0D0) RH = 1.0D0
                        IF (KFLAG .EQ. 0 .AND. RH .LT. 1.1D0) GO TO 590
                           IF (KFLAG .LE. -2) RH = DMIN1(RH,0.2D0)
C                          ---------------------------------------------
C                           IF THERE IS A CHANGE OF ORDER, RESET NQ, L,
C                           AND THE COEFFICIENTS.  IN ANY CASE H IS
C                           RESET ACCORDING TO RH AND THE YH ARRAY IS
C                           RESCALED.  THEN EXIT FROM 680 IF THE STEP
C                           WAS OK, OR REDO THE STEP OTHERWISE.
C                          ---------------------------------------------
C                 .........EXIT
                           IF (NEWQ .EQ. NQ) GO TO 650
                           NQ = NEWQ
                           L = NQ + 1
                           IRET = 2
C           ...............EXIT
                           GO TO 680
  590                   CONTINUE
                        IALTH = 3
                        R = 1.0D0/TESCO(2,NQU)
                        DO 600 I = 1, N
                           ACOR(I) = ACOR(I)*R
  600                   CONTINUE
C     ..................EXIT
                        GO TO 690
  610                CONTINUE
C                    ---------------------------------------------------
C                     CONTROL REACHES THIS SECTION IF 3 OR MORE FAILURES
C                     HAVE OCCURED.  IF 10 FAILURES HAVE OCCURRED, EXIT
C                     WITH KFLAG = -1.  IT IS ASSUMED THAT THE
C                     DERIVATIVES THAT HAVE ACCUMULATED IN THE YH ARRAY
C                     HAVE ERRORS OF THE WRONG ORDER.  HENCE THE FIRST
C                     DERIVATIVE IS RECOMPUTED, AND THE ORDER IS SET TO
C                     1.  THEN H IS REDUCED BY A FACTOR OF 10, AND THE
C                     STEP IS RETRIED, UNTIL IT SUCCEEDS OR H REACHES
C                     HMIN.
C                    ---------------------------------------------------
                     IF (KFLAG .NE. -10) GO TO 620
C                       ------------------------------------------------
C                        ALL RETURNS ARE MADE THROUGH THIS SECTION.  H
C                        IS SAVED IN HOLD TO ALLOW THE CALLER TO CHANGE
C                        H ON THE NEXT STEP.
C                       ------------------------------------------------
                        KFLAG = -1
C     ..................EXIT
                        GO TO 690
  620                CONTINUE
                     RH = 0.1D0
                     RH = DMAX1(HMIN/DABS(H),RH)
                     H = H*RH
                     DO 630 I = 1, N
                        Y(I) = YH(I,1)
  630                CONTINUE
                     CALL DF(TN,Y,SAVF,RPAR,IPAR)
                     NFE = NFE + 1
                     DO 640 I = 1, N
                        YH(I,2) = H*SAVF(I)
  640                CONTINUE
                     IPUP = MITER
                     IALTH = 5
C              ......EXIT
                     IF (NQ .NE. 1) GO TO 670
                  GO TO 170
  650             CONTINUE
  660             CONTINUE
                  RH = DMAX1(RH,HMIN/DABS(H))
               GO TO 110
  670          CONTINUE
               NQ = 1
               L = 2
               IRET = 3
  680       CONTINUE
         GO TO 70
  690 CONTINUE
      HOLD = H
      JSTART = 1
      RETURN
C     ----------------------- END OF SUBROUTINE DSTOD
C     -----------------------
      END
      DOUBLE PRECISION FUNCTION DVNORM(V,NCOMP)
C***BEGIN PROLOGUE  DVNORM
C***REFER TO  DDERKF,DDEABM,DDEBDF
C     COMPUTE THE MAXIMUM NORM OF THE VECTOR V(*) OF LENGTH NCOMP AND
C     RETURN THE RESULT AS DVNORM
C***ROUTINES CALLED  (NONE)
C***END PROLOGUE  DVNORM
C
      INTEGER K, NCOMP
      DOUBLE PRECISION DABS, DMAX1, V
      DIMENSION V(NCOMP)
C***FIRST EXECUTABLE STATEMENT  DVNORM
      DVNORM = 0.0D0
      DO 10 K = 1, NCOMP
         DVNORM = DMAX1(DVNORM,DABS(V(K)))
   10 CONTINUE
      RETURN
      END
      DOUBLE PRECISION FUNCTION DVNRMS(N,V,W)
C***BEGIN PROLOGUE  DVNRMS
C***REFER TO  DDEBDF
C   DVNRMS COMPUTES A WEIGHTED ROOT-MEAN-SQUARE VECTOR NORM FOR THE
C   INTEGRATOR PACKAGE DDEBDF.
C***ROUTINES CALLED  (NONE)
C***END PROLOGUE  DVNRMS
      INTEGER I, N
      DOUBLE PRECISION DBLE, DSQRT, SUM, V, W
      DIMENSION V(N),W(N)
C***FIRST EXECUTABLE STATEMENT  DVNRMS
      SUM = 0.0D0
      DO 10 I = 1, N
         SUM = SUM + (V(I)/W(I))**2
   10 CONTINUE
      DVNRMS = DSQRT(SUM/DBLE(FLOAT(N)))
      RETURN
C     ----------------------- END OF FUNCTION DVNRMS
C     ------------------------
      END
      INTEGER FUNCTION IDAMAX(N,DX,INCX)
C***BEGIN PROLOGUE  IDAMAX
C***DATE WRITTEN   791001   (YYMMDD)
C***REVISION DATE  820801   (YYMMDD)
C***CATEGORY NO.  D1A2
C***KEYWORDS  BLAS,LINEAR ALGEBRA,VECTOR,MAXIMUM COMPONENT,
C             DOUBLE PRECISION
C***AUTHOR  LAWSON, C. L., (JPL)
C           HANSON, R. J., (SNLA)
C           KINCAID, D. R., (U. OF TEXAS)
C           KROGH, F. T., (JPL)
C***PURPOSE  FIND LARGEST COMPONENT OF D.P. VECTOR
C***DESCRIPTION
C                B L A S  SUBPROGRAM
C    DESCRIPTION OF PARAMETERS
C
C     --INPUT--
C        N  NUMBER OF ELEMENTS IN INPUT VECTOR(S)
C       DX  DOUBLE PRECISION VECTOR WITH N ELEMENTS
C     INCX  STORAGE SPACING BETWEEN ELEMENTS OF DX
C
C     --OUTPUT--
C   IDAMAX  SMALLEST INDEX (ZERO IF N .LE. 0)
C
C     FIND SMALLEST INDEX OF MAXIMUM MAGNITUDE OF DOUBLE PRECISION DX.
C     IDAMAX =  FIRST I, I = 1 TO N, TO MINIMIZE  ABS(DX(1-INCX+I*INCX)
C***REFERENCES  LAWSON C.L., HANSON R.J., KINCAID D.R., KROGH F.T.,
C                 *BASIC LINEAR ALGEBRA SUBPROGRAMS FOR FORTRAN USAGE*,
C                 ALGORITHM NO. 539, TRANSACTIONS ON MATHEMATICAL
C                 SOFTWARE, VOLUME 5, NUMBER 3, SEPTEMBER 1979, 308-323
C***ROUTINES CALLED  (NONE)
C***END PROLOGUE  IDAMAX
C
      DOUBLE PRECISION DX(1),DMAX,XMAG
C***FIRST EXECUTABLE STATEMENT  IDAMAX
      IDAMAX = 0
      IF(N.LE.0) RETURN
      IDAMAX = 1
      IF(N.LE.1)RETURN
      IF(INCX.EQ.1)GOTO 20
C
C        CODE FOR INCREMENTS NOT EQUAL TO 1.
C
      DMAX = DABS(DX(1))
      NS = N*INCX
      II = 1
          DO 10 I = 1,NS,INCX
          XMAG = DABS(DX(I))
          IF(XMAG.LE.DMAX) GO TO 5
          IDAMAX = II
          DMAX = XMAG
    5     II = II + 1
   10     CONTINUE
      RETURN
C
C        CODE FOR INCREMENTS EQUAL TO 1.
C
   20 DMAX = DABS(DX(1))
      DO 30 I = 2,N
          XMAG = DABS(DX(I))
          IF(XMAG.LE.DMAX) GO TO 30
          IDAMAX = I
          DMAX = XMAG
   30 CONTINUE
      RETURN
      END

